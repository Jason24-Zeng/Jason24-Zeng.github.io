<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ 技巧 | Jason &amp; Anita's Blog</title><meta name="keywords" content="C++,Coding Technique"><meta name="author" content="Jason Zeng, Anita Xiong"><meta name="copyright" content="Jason Zeng, Anita Xiong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="C++ 技巧C++ 技巧这个话题很大， 对于练习时长不足两年半的我根本没法表述清楚，但是在日常的工作中，又会频繁得跟 C++ 打交道，这使我迫切得需要开这样一篇话题，记录并提炼出通过从书籍和日常工作中得到的知识和经验。好好利用好 C++ 这个强大的武器，使未来的工作或学习更加一帆风顺。 以下记录的，都是我在日常工作中「经常使用到的」，或者在「优化时发现能提升效率」的技巧。很可能技巧都比较简单，但是">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 技巧">
<meta property="og:url" content="https://jason24-zeng.github.io/2023/02/04/C-%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="Jason &amp; Anita&#39;s Blog">
<meta property="og:description" content="C++ 技巧C++ 技巧这个话题很大， 对于练习时长不足两年半的我根本没法表述清楚，但是在日常的工作中，又会频繁得跟 C++ 打交道，这使我迫切得需要开这样一篇话题，记录并提炼出通过从书籍和日常工作中得到的知识和经验。好好利用好 C++ 这个强大的武器，使未来的工作或学习更加一帆风顺。 以下记录的，都是我在日常工作中「经常使用到的」，或者在「优化时发现能提升效率」的技巧。很可能技巧都比较简单，但是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jason24-zeng.github.io/img/C-usable-example/C.png">
<meta property="article:published_time" content="2023-02-04T10:00:06.000Z">
<meta property="article:modified_time" content="2023-03-02T15:52:45.882Z">
<meta property="article:author" content="Jason Zeng, Anita Xiong">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Coding Technique">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jason24-zeng.github.io/img/C-usable-example/C.png"><link rel="shortcut icon" href="/img/kobe.jpeg"><link rel="canonical" href="https://jason24-zeng.github.io/2023/02/04/C-%E6%8A%80%E5%B7%A7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ 技巧',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-02 23:52:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/kobe.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">69</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fa fa-book"></i><span> Find</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/C-usable-example/C.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jason &amp; Anita's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fa fa-book"></i><span> Find</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ 技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-04T10:00:06.000Z" title="Created 2023-02-04 18:00:06">2023-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-02T15:52:45.882Z" title="Updated 2023-03-02 23:52:45">2023-03-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding-Language/">Coding Language</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding-Language/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>35min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ 技巧"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="C-技巧"><a href="#C-技巧" class="headerlink" title="C++ 技巧"></a>C++ 技巧</h2><p>C++ 技巧这个话题很大， 对于练习时长不足两年半的我根本没法表述清楚，但是在日常的工作中，又会频繁得跟 C++ 打交道，这使我迫切得需要开这样一篇话题，记录并提炼出通过从书籍和日常工作中得到的知识和经验。好好利用好 C++ 这个强大的武器，使未来的工作或学习更加一帆风顺。</p>
<p>以下记录的，都是我在日常工作中「经常使用到的」，或者在「优化时发现能提升效率」的技巧。很可能技巧都比较简单，但是从我微不足道的经验来看，令人受益匪浅。</p>
<h3 id="P2-编译期-Assertions（断言）"><a href="#P2-编译期-Assertions（断言）" class="headerlink" title="P2 编译期 Assertions（断言）"></a>P2 编译期 Assertions（断言）</h3><p>随着泛型编程的大量使用，我们越来越需要更好的静态检查（static checking）以及更个性化的错误信息输出。</p>
<p>假使我们想要设计一个做 safe casting 的函数，也就是想要在讲一个类型转变成另一个类型时，所有的信息都能被保留。或者说，大类型不能被 cast 成小类型。</p>
<p>我们可以先简单设计出如下的模板函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="keyword">class</span> <span class="title">From</span>&gt;</span></span><br><span class="line"><span class="function">To <span class="title">safe_reinterpret_cast</span><span class="params">(From from)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(From) &lt;= <span class="built_in"><span class="keyword">sizeof</span></span>(To));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;To&gt;(from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假使我们使用同样的语法调用这个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = ...;</span><br><span class="line"><span class="keyword">char</span>* p = safe_reinterpret_cast&lt;<span class="keyword">char</span>*&gt;(i);</span><br></pre></td></tr></table></figure>
<p>显然，这段代码是想将 <code>int</code> 类型的数据 safe cast 成 <code>char*</code> 类型。不过这里有<strong>几个</strong>可以优化的地方：<code>assert()</code> 内部的结果其实是一个<strong>编译期常量</strong>，但是 <code>assert()</code> 函数只有在<strong>运行期</strong>才会报错，这可能会导致我们在将代码迁移到其他系统时，无法发现并定位错误。我们可以</p>
<ol>
<li><p>考虑如何将报错提前到编译期。</p>
</li>
<li><p>考虑编译期报错时如何输出有效信息。 </p>
</li>
</ol>
<p>Van Horn  曾经就考虑过这个问题，他依赖长度为 0 的数组是非法的原则，设计了一种编译期报错的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123;char unnamed[(expr) ? 1: 0]&#125;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="keyword">class</span> <span class="title">From</span>&gt;</span></span><br><span class="line"><span class="function">To <span class="title">safe_reinterpret_cast</span><span class="params">(From from)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">STATIC_CHECK</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(From) &lt;= <span class="built_in"><span class="keyword">sizeof</span></span>(To));</span><br><span class="line">    <span class="keyword">return</span> interpret_cast&lt;To&gt;(From);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span>* somePointer = ...;</span><br><span class="line"><span class="keyword">char</span> c = safe_reinterpret_cast&lt;<span class="keyword">char</span>&gt;(somePointer);</span><br></pre></td></tr></table></figure>
<p>如果系统指针比 char 要大，编译器就会报错，说我们尝试创造一个长度为 0 的数组。</p>
<p>不过这样问题也比较明显：错误信息太模糊了，而且很难提供可移植性的个性化错误信息。错误信息没有一定需要遵循的规则，这些规则都是由编译器决定。</p>
<p>更好的解决方法是去依赖一个有信息名字的模板，幸运的话，编译器会在错误信息中提到模板的名字。我们可以设计成如下情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span>&gt; <span class="class"><span class="keyword">struct</span> <span class="title">CompileTimeChecker</span> &#123;</span></span><br><span class="line">    <span class="built_in">CompileTimeChecker</span>(...);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">CompileTimeChecker</span>&lt;</span><span class="literal">false</span>&gt; &#123; &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr, msg) \</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    class ERROR_##msg &#123;&#125;; \</span></span><br><span class="line"><span class="meta">    (void)sizeof(CompileTimeChecker<span class="meta-string">&lt;(expr) != 0&gt;</span>((ERROR_##msg()))); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="keyword">class</span> <span class="title">From</span>&gt;</span></span><br><span class="line"><span class="function">To <span class="title">safe_reinterpret_cast</span><span class="params">(From from)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">STATIC_CHECK</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(From) &lt;= <span class="built_in"><span class="keyword">sizeof</span></span>(To),</span><br><span class="line">        Destination_Type_Too_Narrow);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;To&gt;(from);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span>* somePointer = ...;</span><br><span class="line"><span class="keyword">char</span> c = safe_reinterpret_cast&lt;<span class="keyword">char</span>&gt;(somePointer);</span><br></pre></td></tr></table></figure>
<p>这样的话，报错信息就可能变成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Cannot convert ERROR_Destination_Type_Too_Narrow to CompileTimeChecker&lt;<span class="literal">false</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="P0-模板偏特化"><a href="#P0-模板偏特化" class="headerlink" title="P0 模板偏特化"></a>P0 模板偏特化</h3><p>模板偏特化允许我们对模板可实例化集合中的一个子集进行特化。这也是在泛型编程中经常使用的技术。</p>
<p>下面通过一个例子去简单介绍什么是模板偏特化。</p>
<p>首先，我们假设有一个模板 <code>Widget</code>，它有两个类型参数，如下式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Window</span>, <span class="keyword">class</span> <span class="title">Controller</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="comment">// 泛型实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>而后，我们可以对这个类进行显式的特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&lt;</span>ModalDialog, MyController&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在看到如上的特化定义后，无论我们在哪里定义一个类型为 <code>Widget&lt;ModalDialog, MyController&gt;</code> 的对象，编译器都会使用特化实现的版本，而对<code>Widget</code> 的其他实现，编译器则会使用泛型的实现。</p>
<p>然后，我们有时候想对任意的 <code>Window</code> 和 特定的 <code>Controller</code>(这里假设是 <code>MyController</code>) 进行特化实现，这时，我们就会使用到模板的偏特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Window</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&lt;</span>Window, MyController&gt; &#123;</span><br><span class="line">    <span class="comment">// 模板偏特化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特别地，在一个类模板的偏特化中，你只会指定一部分模板参数，而保持另一部分模板参数的泛化性。当我们实例化程序中的类模板时，编译器会尝试找到最匹配的。这个匹配算法是复杂且准确的，这意味着，即使我们已经有一个 <code>Widget</code> 在任意 <code>Window</code> 和指定的 <code>MyContorller</code> 的偏特化模板，我们还可以偏特化下面的类模板，且在编译时依然能保证准确性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ButtonArg</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&lt;</span>Button&lt;ButtonArg&gt;, MyController&gt; &#123;</span><br><span class="line">    <span class="comment">// 进一步的模板偏特化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确保了我们在实例化模板时的灵活性，但需要注意一点，我们不能偏特化函数：无论是成员函数还是非成员函数：</p>
<ul>
<li><p>即使我们能完全特化一个类模板的成员函数，我们不能偏特化类成员函数（这里的为什么，等后续补充）</p>
</li>
<li><p>对命名空间级别的(非成员的)模板函数，我们也不能偏特化，但是我们可以做一个非常接近的操作，就是重载（overloading），在实际应用中，这意味着我们只能对函数的参数做细粒度的特化，而不是对返回值或内部使用类型，比如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="function">T <span class="title">Fun</span><span class="params">(U obj)</span></span>; <span class="comment">// 原始模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="keyword">void</span> Fun&lt;<span class="keyword">void</span>, U&gt;(U obj); <span class="comment">// 非法偏特化, 不能对返回值做细粒度特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="function">T <span class="title">Fun</span><span class="params">(Window obj)</span></span>; <span class="comment">// 合法重载</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对编译器编写者而言，偏特化缺乏粒度的特性，显然让生活更容易，但是对开发者来说，却有不好的影响，后面的一个工具特别是为了减少这种偏特化的限制。</p>
<h3 id="P1-局部类"><a href="#P1-局部类" class="headerlink" title="P1 局部类"></a>P1 局部类</h3><p>我们能在函数里定义类，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Local</span> &#123;</span></span><br><span class="line">        ... 成员变量 member variables ...</span><br><span class="line">        ... 成员函数定义 member function definitions ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ... 使用 Local 这个类的代码 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，局部类有一些限制：</p>
<ol>
<li>不能定义静态成员变量</li>
<li>无法使用统一命名空间里的非静态局部变量</li>
</ol>
<p>不过，这个局部类有趣的地方是：你能在模板函数中使用他们。特别的，在模板函数中定义的局部类能使用 enclosing 函数的模板变量。</p>
<p>下面这个模板函数 <code>MakeAdapter</code> 目的是让一个接口适用于另一个。有了局部类的帮助，<code>MakeAdapter</code> 及时实现了一个接口。局部类存储了泛型的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interface</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="function">Interface* <span class="title">MakeAdapter</span><span class="params">(<span class="keyword">const</span> T&amp; obj, <span class="keyword">const</span> P&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Local</span> :</span> <span class="keyword">public</span> Interface &#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">Local</span>(<span class="keyword">const</span> T&amp; obj, <span class="keyword">const</span> P&amp; arg)</span><br><span class="line">            : <span class="built_in">obj_</span>(obj), <span class="built_in">arg_</span>(arg) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            obj_.<span class="built_in">Call</span>(arg_);</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        T obj_；</span><br><span class="line">        P arg_;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Local</span>(obj, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部类有一个独特的特征：他们是 final 的。外部用户不能从一个函数内部的类继承。如果没有局部类，我们不得不在一个隔离的翻译单元中增加一个未命名的命名空间。</p>
<h3 id="P1-将实常数映射成类型"><a href="#P1-将实常数映射成类型" class="headerlink" title="P1 将实常数映射成类型"></a>P1 将实常数映射成类型</h3><p>有一个非常简单的模板，对许多泛型编程 idioms（习语）有用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> v&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int2Type</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>value = v&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Int2Type</code> 对输入的不同常实数会生成不同的类型，这是因为不同的模板实例化是不同的类型。另外，产生这个类型的值，会被保存在枚举成员 <code>value</code> 中</p>
<p>这个模板为什么被广泛应用呢？无论何时我们需要给一个常实数附以类型时，我们都可以使用它。通过这个方式，我们可以依赖编译期计算的结果，去选择不同的函数，从而可以有效得依赖一个常实数实现静态分派（static dispatch）</p>
<p>典型的，在如下两个情况都满足的时候，我们应该使用 <code>Int2Type</code> ：</p>
<ol>
<li><p>取决于一个编译期常数，我们会去挑选几个不同函数中的一个</p>
</li>
<li><p>我们需要在编译期做这样的分派</p>
</li>
</ol>
<p>对于运行期的分派，我们可以简单地使用 <code>if-else</code> 语句或者 <code>switch</code> 的语句。运行期的消耗在大多数情况下可忽略不计。但是，我们通常不这么做。（不这么做的原因不是运行期更耗时）<code>if-else</code> 语句要求两个分支都得成功编译，即使我们在编译期时就可以知道 <code>if</code> 条件的选择情况。</p>
<p>下面通过一个例子来解释上面这句话的意思。</p>
<p>假设我们正在设计一个泛型容器 <code>NiftyContainer</code>，这个容器被包含的类型模板化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假使 <code>NiftyContainer</code> 容器包含了指向类型 <code>T</code> 的对象的指针。为了复制包含在容器中的对象，我们要么调用它自身的拷贝构造函数，要么调用一个为多态类型（polymorhic types）准备得虚函数 <code>Clone()</code>。至于选择哪种函数，我们可以通过一个布尔类型的模板参数获得信息。</p>
<p>为此，我们很容易想到以下的实现方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* pSomeObj = ...;</span><br><span class="line">        <span class="keyword">if</span> (isPolymorphic) &#123;</span><br><span class="line">            T* pNewObj = pSomeObj-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">            <span class="comment">// ...多态算法...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T* pNewObj = <span class="keyword">new</span> <span class="built_in">T</span>(*pSomeObj);</span><br><span class="line">            <span class="comment">// ...非多态算法...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样实现可能让编译器通不过编译。比如，多态算法要求使用 <code>Clone</code> 成员函数，如果任何类型没有定义一个这样的成员函数，<code>NiftyContainer::DoSomething</code> 将不能编译。的确我们在编译的时候已经能决定执行哪个 if 状态了，但是，编译器不会管这些，他会尝试编译两个分支，即使优化器后面会删除无用的代码。也就是说，我们可能会出现这样的情况：我们尝试调用 <code>NiftyContainer&lt;int, false&gt;</code> 的 <code>DoSomething</code> 函数，编译器却在 <code>pObj-&gt;Clone()</code> 处报错了。</p>
<p>另外，非多态分支的代码也可能编译失败，如果 <code>T</code> 是一个多态类型并且非多态代码分支尝试 <code>new</code> 一个 <code>T(*pObj)</code> ，这也可能导致代码编译失败：如果 <code>T</code> 禁用了拷贝构造函数或者让拷贝构造函数变成私有的。PS. 好的多态类就应该做这些考虑。</p>
<p>让编译器不用操心代码是否是无用，这个想法是好的，但是有更让人满意的解决方法，在使用这个简洁的解决方法的时候，我们会用到 <code>Int2Type</code>：它会根据布尔值 <code>isPolymorphic</code> 的不同，将其即时得转变成两个不同的类型，然后我们就可以利用简单的重载去使用 <code>Int2Type&lt;isPolymorhic&gt;</code> 啦。代码重构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(T* pObj, Int2Type&lt;<span class="literal">true</span>&gt;)</span> </span>&#123;</span><br><span class="line">        T* pNewObj = pObj-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">        <span class="comment">// ...多态算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(T* pObj, Int2Type&lt;<span class="literal">false</span>&gt;)</span> </span>&#123;</span><br><span class="line">        T* pNewObj = <span class="keyword">new</span> <span class="built_in">T</span>(*pSomeObj);</span><br><span class="line">        <span class="comment">// ...非多态算法...</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(T* pObj)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DoSomething</span>(pObj, Int2Type&lt;isPolymorphic&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个重载实现了两个需要的算法，这上面的 trick 点在于，因为编译器不会编译它们不适用的模板函数，它只检查它们语法。这样，我们就在编译期实现了模板代码的分派。</p>
<h3 id="P1-类型到类型-Type2Type-的映射"><a href="#P1-类型到类型-Type2Type-的映射" class="headerlink" title="P1 类型到类型 Type2Type 的映射"></a>P1 类型到类型 Type2Type 的映射</h3><p>前面已经提到，我们不能对模板函数进行偏特化，但是，有时我们又需要模拟相似的功能。参考下面函数，它会通过将参数传给构造函数的方式，创建一个新的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设我们的应用中有一个规则：</p>
<ol>
<li><p>类型为 <code>Widget</code> 的对象是不能碰的遗留代码，我们想要构建必须传入两个参数，第二个参数必须是一个固定值，比如 -1。</p>
</li>
<li><p>从 <code>Widget</code> 继承过来的类，不会有这个问题。</p>
</li>
</ol>
<p>现在的问题是：我们怎么特化 <code>Create</code> 来让它用和其他类型不同的方式处理 <code>Widget</code>? 显而易见的一种方法，是创造一个单独的<code>CreateWidget</code> 函数去解决特殊的问题。但是，你没有一个统一的接口去创建 <code>Widget</code>s 和它的继承对象，从而让 <code>Create</code> 在任何泛型代码中不好用。 </p>
<p>就像刚开始就提到的，我们不能偏特化一个函数，具体在这个例子中便是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">Widget* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(arg, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决这一类问题仅有的工具是重载 overloading，一种办法是传一个类型为 T 的 dummy 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg, T <span class="comment">/* dummy */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">Widget* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg, Widget <span class="comment">/* dummy */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Widget</span>(arg, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的解决方式很容易让我们创建一个随意的复杂对象，但是我们却永远不会使用它。我们需要个更轻便的载体去将关于 <code>T</code> 的类型信息传给 <code>Create</code>，这时候我们就可以考虑使用 <code>Type2Type</code>，一个类型的代表，一个可以传递给重载函数的轻标识符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type2Type</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T OriginalType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出 <code>Type2Type</code> 不包含任意值，但是有一个不同的类型引导实例化不同的 <code>Type2Type</code>，这正是我们想要的。有了这个工具，我们就可以轻松写下如下优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg, Type2Type&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">T</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="function">Widget* <span class="title">Create</span><span class="params">(<span class="keyword">const</span> U&amp; arg, Type2Type&lt;Widget&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Widget</span>(arg, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Create()</span></span><br><span class="line">String* pStr = <span class="built_in">Create</span>(<span class="string">&quot;Hello&quot;</span>, Type2Type&lt;String&gt;());</span><br><span class="line">Widget* pW = <span class="built_in">Create</span>(<span class="number">100</span>, Type2Type&lt;Widget&gt;());</span><br></pre></td></tr></table></figure>
<p><code>Create</code> 的第二个参数只是用来选择合理的重载，现在我们能对不同的 <code>Type2Type</code> 实例去特化 <code>Create</code>。</p>
<h3 id="P2-类型选择"><a href="#P2-类型选择" class="headerlink" title="P2 类型选择"></a>P2 类型选择</h3><p>有些泛型代码会根据一个布尔常数去选择两个类型中的一种。这一章就是要讨论这个的实现。</p>
<p>举个前面提到的例子 <code>NiftyContainer</code>，假设我们想要在底层存储中使用 <code>std::vector</code>。显然，对多态类型我们必须存储指针而非值本身，而对非多态类型，我们可能想要存储值，因为这更加方便高效。</p>
<p>首先是 <code>NifityContainer</code> 这个类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要存储要么一个 <code>vector&lt;T*&gt;</code> （<code>isPolymorphic</code> 为 <code>true</code>）要么一个 <code>vector&lt;T&gt;</code> （<code>isPolymorphic</code> 为 <code>false</code>）。总之，我们需要根据 <code>isPolymorphic</code> 的值决定定义的  <code>ValueType</code>要么是 <code>T*</code>，要么是<code>T</code>。</p>
<p>我们可以定义一个如下的特征类模板解决问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NiftyContainerValueTraits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T* ValueType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NiftyContainerValueTraits</span>&lt;</span>T, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T ValueType;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> NiftyContainerValueTraits&lt;T, isPolymorphic&gt;</span><br><span class="line">        Traits;</span><br><span class="line">    <span class="keyword">typedef</span> typanme Traits::ValueType ValueType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种处理问题的方式显得不必要的笨重，并且，他没法扩展，每次类型选择，我们都必须定义一个信息的特征类型模板。</p>
<p>库类模板 <code>Select</code> 给我们提供了一个能完美解决问题的类型选择方法。它的定义使用了模板偏特化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> flag, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Select</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T Result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Select</span>&lt;</span><span class="literal">false</span>, T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> U Result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里解释一下这个 <code>Select</code> 怎么工作的。</p>
<ol>
<li><p>当 <code>flag</code> 为 <code>true</code> 时，编译器会使用第一个泛型定义因此 <code>Result</code> 等于 <code>T</code></p>
</li>
<li><p>当 <code>flag</code> 为 <code>false</code> 时，特化的模板被使用，因此 <code>Result</code> 等于 <code>U</code></p>
</li>
</ol>
<p>现在，我们就能更简单得定义 <code>NiftyContainer::ValueType</code> 了，而且也更容易扩展了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">bool</span> isPolymorphic&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NiftyContainer</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Select&lt;isPolymorphic, T*, T&gt;::Result</span><br><span class="line">        ValueType;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="P1-在编译期检测可转化性和继承性"><a href="#P1-在编译期检测可转化性和继承性" class="headerlink" title="P1 在编译期检测可转化性和继承性"></a>P1 在编译期检测可转化性和继承性</h3><p>我们在实现模板函数和模板类时，经常会想一个问题：给定随意两种类型 <code>T</code> 和 <code>U</code> ，我们该怎么检测是否 <code>U</code> 为 <code>T</code> 的继承呢？在编译期发现这样的关系是在泛型库类实现高级优化的关键。在一个泛型函数中，如果我们能确定这个类实现了某一个特殊的接口，我们就可以根据这个信息去采用最佳算法。在编译器发现这个意味着我们不用使用 在编译期及其耗时的<code>dynamic_cast</code>。</p>
<p>发现继承关系依赖一个甄别可转化性的更一般化的机制。而更一般的问题是，我们要怎么检测随机的一个类型 <code>T</code> 是否支持向 <code>U</code> 的自动转化。</p>
<p>有一种解决方法，它会依赖 <code>sizeof</code> 的实现。<code>sizeof</code> 有着许多令人吃惊的力量：我们可以对任何表达式使用<code>sizeof</code>，不管这个表达式多么的复杂，它能返回表达式的大小，且不用拖到运行期。这意味着 <code>sizeof</code> 能意识到重载，模板实例化，转化规则等一切参与 C++ 表达式的东西。事实上，<code>sizeof</code> 背后暗含一个用来推到表达式类型的完整设施。最终，<code>sizeof</code> 会丢弃表达式并且只返回结果的大小。</p>
<p>检测转换能力 的想法依赖于 <code>sizeof</code> 与 重载函数的共用。我们提供一个函数的两个重载，一个接受类型，并且将其转化成 <code>U</code>，另一个接受其他任何类型。我们用一个临时的类型 <code>T</code> 去调用重载函数，而<code>T</code> 对 <code>U</code> 的可转换能力正式我们想要判断的。如果前一个调用 <code>U</code> 的函数被调用，那我们知道 <code>T</code> 能转化成<code>U</code>，如果的另一个函数被调用，那么 <code>T</code> 就不能被转化成 <code>U</code>。我们设计两个重载函数返回不同大小的类型，然后便可以使用<code>sizeof</code> 去判断了。这两个类型本身不重要，只要它们大小不同就行。</p>
<p>ok，解释到这里了，我们来具体实现以下它。</p>
<p>首先，我们创建两个不同大小的类型，显然 <code>char</code> 和 <code>long double</code> 有不同的大小，但是 C++ 标准并不保证一定不同，一个傻瓜式的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Small;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Big</span> &#123;</span><span class="keyword">char</span> dummy[<span class="number">2</span>]&#125;;</span><br></pre></td></tr></table></figure>
<p>根据定义，<code>sizeof(Small)</code> 为 1，<code>Big</code> 的大小未知，但一定大于 1，这是我们唯一能保证的东西。</p>
<p>下一步，我们需要两个重载函数，一个接受 <code>U</code> 并且返回一个 <code>Small</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Small <span class="title">Test</span><span class="params">(U)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们怎么写一个函数接受其他任何呢？一个模板不是解决方法，因为模板总是要求最佳匹配条件，因此掩盖可转化的类型。我们需要一个匹配，这个匹配会比自动转化更糟糕，也就是，转化只会在没有自动转化时发生。我很快看了一下施行于函数调用的转化规则，然后发现了所谓的省略符匹配规则（ellipsis match），这时最差的匹配了，也是我们正好希望的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Big <span class="title">Test</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>传一个 C++ 的对象到有省略符的函数会有未定义的结果，但这不重要。事实上没有东西会真的调用这个函数，它甚至不会实现。想想 <code>sizeof</code> 实际不会衡量函数的入参。</p>
<p>现在，我们需要实施 <code>sizeof</code> 到 <code>Test</code> 的调用，给它传递一个 <code>T</code> 作为入参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> convExists = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="built_in">Test</span>(<span class="built_in">T</span>())) == <span class="built_in"><span class="keyword">sizeof</span></span>(Small);</span><br></pre></td></tr></table></figure>
<p>对，<code>Test</code> 的调用得到一个默认构造对象 <code>T()</code>，然后 <code>sizeof</code> 会分离出表达式结果的大小，它要么是 <code>sizeof(Small)</code> 要么是 <code>sizeof(Big)</code>，这取决于是否编译器能发现一种转化。</p>
<p>有一个小问题，如果 <code>T</code> 的默认构造函数是私有的，表达式 <code>T()</code> 会在编译时失败，我们的所有努力都会没有回报，不够新云的是，有一个非常简单的解决方法，就是使用一个稻草人函数（strawman function），它返回一个 T 对象（记住，我们在处于 <code>sizeof</code> 的神奇世界中，没有表达式会被实际求值）。因此，编译器和我们都会非常满意。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">MakeT</span><span class="params">()</span></span>;  <span class="comment">// 没有实现，不止不会做任何是，甚至在运行期都没有真实存在过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> convExists = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="built_in">Test</span>(<span class="built_in">MakeT</span>())) == <span class="built_in"><span class="keyword">sizeof</span></span>(Small);</span><br></pre></td></tr></table></figure>
<p>现在我们把这个函数类的所有东西包裹在一起，隐藏类型推导的所有细节，只展现结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coversion</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">char</span> Small;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Big</span> &#123;</span><span class="keyword">char</span> dummy[<span class="number">2</span>];&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Small <span class="title">Test</span><span class="params">(U)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Big <span class="title">Test</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">MakeT</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        exists = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="built_in">Test</span>(<span class="built_in">MakeT</span>())) == <span class="built_in"><span class="keyword">sizeof</span></span>(Small);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以测试 <code>Coversion</code> 类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; Conversion&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;::exists &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">         &lt;&lt; Conversion&lt;<span class="keyword">char</span>, <span class="keyword">char</span>*&gt;::exists &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">         &lt;&lt; Conversion&lt;<span class="keyword">size_t</span>, vector&lt;<span class="keyword">int</span>&gt;&gt;::exists &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个小程序会打印 <code>1 0 0</code>，注意虽然 <code>vector</code> 的确实现了一个构造函数，这个函数获取一个入参 <code>size_t</code>，但是这个转化测试返回 0，因为那个构造函数时 explicit 的。explicit 构造函数时没法担任转换函数的。</p>
<p>我们能在 <code>Coversion</code> 中增加一个常数 <code>sameType</code>，如果 <code>T</code> 和 <code>U</code> 表示同一个类型时为 <code>true</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conversion</span> &#123;</span></span><br><span class="line">    ...同上...</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>sameType = <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Conversion</code> 的一个片特护来实现 <code>sameType</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conversion</span>&lt;</span>T, T&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>exists = <span class="number">1</span>, sameType = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，有了 <code>Conversion</code> 的帮助，我们现在可以非常容易得定义继承了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUPERSUBCLASS(T, U) \</span></span><br><span class="line"><span class="meta">    (Conversion<span class="meta-string">&lt;const U*, const T*&gt;</span>::exists &amp;&amp; \</span></span><br><span class="line"><span class="meta">    !Conversion<span class="meta-string">&lt;const T*, const void*&gt;</span>::sameType)</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>U</code> 是 public 继承自 <code>T</code>,  或者 <code>T</code> 和 <code>U</code> 是同一类型的，<code>SUPERSUBCLASS(T, U)</code>会传入 <code>true</code>。当 <code>SUPERSUBCLASS</code> 对 <code>const T*</code> 和 <code>const U*</code> 做可转化评估时，只有三种情况 <code>const U*</code> 能隐式转化成 <code>const T*</code>：</p>
<ol>
<li><p><code>T</code>  和 <code>U</code> 同类型</p>
</li>
<li><p><code>T</code> 是 <code>U</code> 的模糊 public 基类</p>
</li>
<li><p><code>T</code> 是 <code>void</code></p>
</li>
</ol>
<p>最后一种情况被第二个测试消除了。实际上，接受第一种情况作为 <code>is-a</code> 的退化情况是非常有用的，因为在实际使用中，我们经常会考虑一个类是它自己的 superclass。如果我们需要更严格的测试，可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUPERSUBCLASS_STRICT(T, U) \</span></span><br><span class="line"><span class="meta">    (SUPERSUBCLASS(T, U) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    !Conversion<span class="meta-string">&lt;const T, const U&gt;</span>::sameType)</span></span><br></pre></td></tr></table></figure>
<p>为什么代码都加上<code>const</code> 修饰？因为我们不想因为 <code>const</code> 导致转型失败，如果模板代码实施了 两次 <code>const</code>，第二个 <code>const</code> 会被忽略掉，总之，保险起见，我们在 <code>SUPERSUBCLASS</code> 中都是用 <code>const</code>。</p>
<h3 id="P2-一个关于-type-info-的外覆类（wrapper）"><a href="#P2-一个关于-type-info-的外覆类（wrapper）" class="headerlink" title="P2 一个关于 type_info 的外覆类（wrapper）"></a>P2 一个关于 <code>type_info</code> 的外覆类（wrapper）</h3><p>标准 C++ 提供了一个类：<code>std::type_info</code> ，它能让我们在运行期调查类的类型。通常 <code>type_info</code> 会和 <code>typeid</code> 操作符并用，后者会传一个指向 <code>type_info</code> 对象的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(Base* pObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较两个 type_info 对象，它们分别与 *pObj 和 Derived 有关</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(*pObj) == <span class="built_in"><span class="keyword">typeid</span></span>(Derived)) &#123;</span><br><span class="line">        <span class="comment">// pObj 事实上指向一个 Derived 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>typeid</code> 操作符返回一个指向类型为 <code>type_info</code> 对象的引用。除了支持比较算法 <code>operator==</code> 和 <code>operator!=</code> 以外，<code>type_info</code>提供了额外的两个函数。</p>
<ul>
<li><p><code>name</code> 成员函数，以 <code>const char*</code> 的格式，返回一个类型的文本表达。因为没有将类名映射成字符串的标准方法，所以我们不应该期望 <code>typeid(Widget)</code> 返回 “Widget” 这样的字符串。一个比较令人满意的做法是让 <code>type_info:name</code> 对所有类型返回空字符串。</p>
</li>
<li><p><code>before</code> 成员函数，它给 <code>type_info</code> 对象带来了一种次序关系。使用 <code>type_info::before</code> ，我们能对 <code>type_info</code> 对象建立索引</p>
</li>
</ul>
<p>不幸的是，<code>type_info</code> 的好用功能被包装得难以使用。<code>type_info</code> 类将拷贝构造函数和拷贝赋值操作符禁用，这使得存储 <code>type_info</code> 对象变得不可能。不过我们可以存储指向 <code>type_info</code> 对象的指针。这个通过 <code>typeid</code> 返回的对象，采用了 static 的存储方式，因此我们不用担心其寿命，但我们得关注指针间的辨识。</p>
<p>C++ 标准不能保证每次调用 <code>typeid(int)</code> 能返回指向同一个 <code>type_info</code> 对象的引用。如此一来，我们没法比较指向 <code>type_info</code> 对象的指针了。为此，我们必须将指针存储到 <code>type_info</code> 对象中，并且通过运用 <code>type_info::operator==</code> 到解引用的方式，进行指针的比较。</p>
<p>如果我们想要对 <code>type_info</code> 对象进行排序，我们事实上必须存储指向 <code>type_info</code> 的指针，并且这次我们必须使用 <code>before</code> 这个成员函数。这样一来，如果我们想要使用 STL 的有序容器，必须写一个小的仿函数 <code>functor</code> 并处理指针。</p>
<p>这些笨拙到足以让我们委派一个关于 <code>type_info</code> 的外覆类来存储指向一个 <code>type_info</code> 的指针，并且，这个外覆类还需要提供：</p>
<ul>
<li><p>所有 <code>type_info</code> 的成员函数</p>
</li>
<li><p>value 的语义（与 reference 相对），即 public 的拷贝构造函数和拷贝赋值操作符</p>
</li>
<li><p>定义 <code>operator&lt;</code> 和 <code>operator==</code> 来保证比较的无暇</p>
</li>
</ul>
<p>Loki 定义了一个外覆类 <code>TypeInfo</code>，它实现了一个与 <code>type_info</code> 有关的，非常方便的外覆类，其大纲如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeInfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TypeInfo</span>();</span><br><span class="line">    <span class="built_in">TypeInfo</span>(<span class="keyword">const</span> std::type_info&amp;);</span><br><span class="line">    <span class="built_in">TypeInfo</span>(<span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line">    TypeInfo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> TypeInfo&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> std::type_info* pInfo_;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 比较操作符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> TypeInfo&amp;, <span class="keyword">const</span> TypeInfo&amp;);</span><br></pre></td></tr></table></figure>
<p>由于其转换构造函数接受一个 <code>std::type_info</code> 的入参，我们能直接比较类型为 <code>TypeInfo</code> 和 <code>std::type_info</code> 的对象，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(Base* pObj)</span> </span>&#123;</span><br><span class="line">    TypeInfo info = <span class="built_in"><span class="keyword">typeid</span></span>(Derived);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(*pObj) == info) &#123;</span><br><span class="line">        <span class="comment">// pBase 事实上指向一个 Derived 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝和比较 <code>TypeInfo</code> 对象在许多情况下都非常重要。</p>
<h3 id="P2-NullType-和-EmptyType"><a href="#P2-NullType-和-EmptyType" class="headerlink" title="P2 NullType 和 EmptyType"></a>P2 <code>NullType</code> 和 <code>EmptyType</code></h3><p>Loki 定义了两个非常简单的类型: <code>NullType</code> 和 <code>EmptyType</code>，我们能在类型计算中使用它们去编辑边界 case。</p>
<p><code>NullType</code> 是一个用于作为类型的空标记（null marker）的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullType</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>我们通常不创造类型为 <code>NullType</code> 的对象，它只被使用来暗示”我的类型不被人感兴趣”（一般是用作模板特化的终止，有点类似于 <code>enable_if</code> 的使用）。</p>
<p>而第二个 helper 类型时 <code>EmptyType</code>，它的定义是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyType</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><code>EmptyType</code> 是一个可被继承的合法类型，且我们可以传递 <code>EmptyType</code> 的对象。同门可以使用这个类型作为模板的默认类型。</p>
<h3 id="P0-Type-Traits"><a href="#P0-Type-Traits" class="headerlink" title="P0 Type Traits"></a>P0 Type Traits</h3><p>Traits 是一种泛型编程技巧，它允许在编译期做一些基于类型的决策，很像我们想要在运行期基于类做的决策。通过加上这个可以解决许多软件工程难题的间接层，traits 能让我们在「类型确定」以外的地方做类型相关的决策。这可以让最终的代码更简洁，更可读，并且更好维护。</p>
<p>通常，当我们的泛型程序需要的时候，我们要写自己的 trait 模板和类。可是，有些 traits，可被用于任何类型，它们可以帮助我们根据类别特性去更好地裁剪模板代码。</p>
<p>比如，设想一下，我们要是想实现一个拷贝算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line"><span class="function">OutIt <span class="title">Copy</span><span class="params">(InIt first, Init last, OutIt result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; first != last; ++first, ++result) &#123;</span><br><span class="line">        *result = *first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上，我们不必实现这样的算法，因为它与 <code>std::copy</code> 功能重复，但我们可能想要对某些特殊的类型特化我们的拷贝链路。</p>
<p>假设我们为一个多处理器机器开发代码，这台机器有一个非常快的 <code>BitBlast</code> 原生函数，并且我们也想尽可能充分利用好这个原生函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prototype of BitBlast in &quot;SIMD_Primitives.h&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitBlast</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* dest, <span class="keyword">size_t</span> bytes)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然 <code>BitBlast</code> 这能在拷贝原生类型和简单的旧数据结构时使用。我们不能对一个有 nontrival 拷贝构造函数的类型使用 <code>BitBlast</code>。然后，我们想要实现 <code>Copy</code>  函数，在可能的时候，它可以利用好 <code>BitBlast</code>, 而对于一些精巧类型，该函数会退化到使用更广泛，保守的算法。这样， <code>Copy</code> 操作符在原生类型的范围内就会自动的跑的更快了。</p>
<p>为了实现这个效果，我们需要对类型做两个测试：</p>
<ol>
<li><p><code>InIt</code> 和 <code>OutIt</code> 是通常的指针么？（相比更 fancy 的迭代器类型而言）</p>
</li>
<li><p><code>InIt</code> 和 <code>OutIt</code> 指针指向的类型允许 bitwise 的拷贝么？</p>
</li>
</ol>
<p>如果我们能在编译器找到这些问题的答案，并且这两个答案都是 yes，我们就可以使用 <code>BitBlast</code>。否则，我们必须依赖最通常的 <code>for</code> 循环。</p>
<p>而 Type Traits 就能帮忙解决这个问题。</p>
<h4 id="实现指针-traits"><a href="#实现指针-traits" class="headerlink" title="实现指针 traits"></a>实现指针 traits</h4><p>Loki 定义了一个类模板 <code>TypeTraits</code> ，它收集了一些列泛型类型的 Traits。<code>TypeTraits</code> 使用内部模板特化，并且将结果暴露出来。</p>
<p>大部分类型 traits 的实现依赖完全特化或者偏特化，比如，下面的代码决定是否一个类型 <code>T</code> 是否是一个指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">PointerTraits</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> &#123;</span> result = <span class="literal">false</span> &#125;;</span><br><span class="line">        <span class="keyword">typedef</span> NullType PointeeType;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">PointerTraits</span>&lt;</span>U*&gt; &#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> &#123;</span> result = <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">typedef</span> U PointeeType;</span><br><span class="line">    &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isPointer = PointerTraits&lt;T&gt;::result &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> PointerTraits&lt;T&gt;::PointeeType PointeeType;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个定义引入了 <code>PointerTraits</code> 类模板，他表示 <code>T</code> 不是一个指针，并且所谓的被指类型不能被运用。（<code>NullType</code> 是一个在不被运用的情况的占位符行别）</p>
<p>第二个定义则是介绍了一种 <code>PointerTraits</code> 的偏特化，是一个可以匹配任何指针类型的特化体。对于指向任意东西的指针，这个特化都会被认为是一个比 「针对任何指针类型的泛型模板」更加合适的候选。总之，如果面对指针，则该特化体运行，<code>result</code> 被赋值为 <code>true</code>，而 <code>PointeeType</code> 被合理得定义。</p>
<p>现在我们可以观察一下 <code>std::vector::iterator</code> 的实现，它是一个简谱的指针呢，还是一个精巧类型？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> IterIsPtr = TypeTraits&lt;vector&lt;<span class="keyword">int</span>&gt;::iterator&gt;::isPointer；</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector&lt;int&gt;::iterator is &quot;</span> &lt;&lt; iterIsPtr ? <span class="string">&quot;fast&quot;</span> : <span class="string">&quot;smart&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相似的，<code>TypeTraits</code> 实现一个 <code>isReference</code> 常数和一个 <code>ReferenceType</code> 类型定义。对于一个引用类型 <code>T</code> ，<code>ReferencedType</code> 是一个 <code>T</code> 指向的类型，如果 <code>T</code> 是一个直接的类型（即非引用），<code>ReferenceType</code> 是 T 自己。</p>
<p>检测指向成员的指针会有一些不同，需要的特化体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">PToMTraits</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> &#123;</span> result = <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="keyword">class</span> <span class="title">V</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">PToMTraits</span>&lt;</span>U V::*&gt; &#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> &#123;</span> result = <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isMemberPointer = PToMTraits&lt;T&gt;::result &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="检测基础类型"><a href="#检测基础类型" class="headerlink" title="检测基础类型"></a>检测基础类型</h4><p><code>TypeTraits&lt;T&gt;</code> 实现了一个 <code>isStdFundamental</code> 编译期常数，这个常数会表明 <code>T</code> 是否是一个 C++ 标准里的基础类型。C++ 标准的基础类型包含类型 <code>type</code> 和所有数字类型，即浮点类型和整型。<code>TypeTraits</code> 定义了一堆常数 用来展现已知类型属于哪种类别的。</p>
<p>可以简单提一下 <code>typelists</code>，其让检测「是否一个类型属于一系列已知类型」变得简单。目前，我们所需要了解的是一下表达：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TL::IndexOf&lt;T, <span class="built_in">TYPELIST_nn</span>(comman-separated list of types)&gt;::value</span><br></pre></td></tr></table></figure>
<p>其中，nn 是类型列表中类型的个数，上面的表达式会返回 T 在列表中的位置（以零为 base），如果 T 不再列表中，就返回 -1。比如，当且晋档 T 是一个有符号整型时，表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TL::IndexOf&lt;T,<span class="built_in">TYPELIST_4</span>(<span class="keyword">signed</span> <span class="keyword">char</span>, <span class="keyword">short</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">int</span>)&gt;::value</span><br></pre></td></tr></table></figure>
<p>会大于等于 0 。</p>
<p>针对基本类型， <code>TypeTraits</code> 有如下部分定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line">    ... as above ...</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">TYPELIST_4</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>, <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> in, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>)</span> UnsignedInts</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">TYPELIST_4</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">char</span>, <span class="keyword">short</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span> <span class="keyword">int</span>)</span> SignedInts</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">TYPELIST_3</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">double</span>, <span class="keyword">long</span> <span class="keyword">double</span>)</span> Floats</span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">TYPELIST_3</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">char</span>, <span class="keyword">wchar_t</span>)</span> OtherInts</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdUnsignedInt = TL::IndexOf&lt;T, UnsignedInts&gt;::value &gt;= <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdsignedInt = TL::IndexOf&lt;T, SignedInts&gt;::value &gt;= <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdIntegral == isStdUnsignedInt || isStdSignedInt ||</span><br><span class="line">        TL::IndexOf&lt;T, OtherInts&gt;::value &gt;= <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdFloat = TL::IndexOf&lt;T, Floats&gt;::value &gt;= <span class="number">0</span> &#125;; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdArith = isStdIntegral || isStdFloat &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> isStdFundamental = isStdArith || isStdFloat ||</span><br><span class="line">          Conversion&lt;T, <span class="keyword">void</span>&gt;::sameType &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用类型列表和 <code>TL::IndexOf</code> 给了我们快速推测类型信息的能力，因此我们不用写一个模板特化体多次。</p>
<p>检测基础类型的真实实现更加复杂，允许更多厂家自行扩展类型（比如 <code>int64</code> 和 <code>long long</code>）</p>
<h4 id="优化的参数类型"><a href="#优化的参数类型" class="headerlink" title="优化的参数类型"></a>优化的参数类型</h4><p>在模板代码，我们优势需要回答如下问题。已知一个随意的类型 <code>T</code>，用什么办法传递和接收类型 <code>T</code> 的对象作为函数的参数最为高效？通常，最有效地方式是：当对象时精细类型时使用 by reference，而对纯量类型时使用 by value。对于精细类型，我们可以避免额外的临时开销（空间开销 + 时间开销），而对纯量类型，我们避免了使用引用的不直接性（时间开销）。</p>
<p>需要认真对待的一个细节是：C++  不允许指向引用的引用，因此，如果 <code>T</code> 已经是一个引用，我们不能在它的基础上加一层引用。</p>
<p>基于大量对函数进行参数优化的分析，我们设计了如下的算法。假设我们正在处理的参数类型为 <code>ParameterType</code>。</p>
<blockquote>
<p>如果 <code>T</code> 是某个类型的引用，<code>ParameterType</code> 和 <code>T</code> 一样，保持不变。因为引用的引用不被允许。</p>
<p>反之，</p>
<pre><code>如果 `T` 是一个纯量类型 `int`，`float` 等， `ParameterType` 是 `T`。因为基础类型最好通过值传递。

如果 `ParameterType` 是 `T` 的一个常量引用 `const T&amp;`，通常，非基础类型最好以引用传递。
</code></pre></blockquote>
<p>这个算法的一个重要成就是：它避免了对引用进行引用的错误。比如，如果我们结合 <code>bind2nd</code> 与 <code>mem_fun</code> 标准库函数，这种错误会出现。</p>
<p>实现 <code>TypeTraits::ParameterType</code> 非常容易，只要使用我们已经掌握的技巧以及之前定义的 traits - <code>ReferencedType</code> 和 <code>isPrimitive</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line">    ... as above ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      typdef Select&lt;isStdArith || isPointer || isMemberPointer, T, ReferencedType&amp;&gt;::Result ParameterType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不幸的是，这个方案如果遇到「以值传递枚举类型时」会失败，因为没有已知的办法去决定是否一个类型是一个枚举类型。</p>
<h4 id="去除-strip-装饰词"><a href="#去除-strip-装饰词" class="headerlink" title="去除 strip 装饰词"></a>去除 strip 装饰词</h4><p>已知一个类型 <code>T</code>，我们很容易借助 <code>const T</code> 取得常数版兄弟。但是，做其相反的操作会有点困难。同样的，优势我们可能想要去掉 <code>volatile</code> 这类修饰词 qualifier。</p>
<p>举个例子，我们考虑构建一个智能指针，对染我们想要允许用户创建指向 <code>const</code> 对象的智能指针，比如 <code>SmartPtr&lt;const Widget&gt;</code>，我们依然需要在内部改变指针，使其指向 <code>Widget</code>。因此，在 <code>SmartPtr</code> 内部，我们需要从 <code>const Widget</code> 里获取到 <code>Widget</code>。</p>
<p>实现一个 <code>const</code> 去除器比较简单，我们需要再次使用到模板的偏特化:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeTraits</span> &#123;</span></span><br><span class="line">    ... as above ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnConst</span> &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> U Result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnConst</span>&lt;</span><span class="keyword">const</span> U&gt; &#123;</span><br><span class="line">        <span class="keyword">typedef</span> U Result;</span><br><span class="line">    &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">typedef</span> UnConst&lt;T&gt;::Result NonConstType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用-TypeTraits"><a href="#使用-TypeTraits" class="headerlink" title="使用 TypeTraits"></a>使用 <code>TypeTraits</code></h4><p><code>TypeTraits</code> 能帮我们做许多有趣的事情。比如：我们可以通过前面这章的技巧来实现 Copy 函数，它会使用 <code>BitBlast</code> （和前面章节提到的一样）；我们可以使用 <code>TypeTraits</code> 去辨别两个迭代器的类别信息，并以 <code>Int2Type</code> 模板去分派 Copy 去调用 <code>BitBlast</code> 还是一个典型的 Copy 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CopyAlgoSelector</span> &#123;</span> Conservative, Fast &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Conservative routine-works for any type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line"><span class="function">OutIt <span class="title">CopyImpl</span><span class="params">(InIt first, InIt last, OutIt result,</span></span></span><br><span class="line"><span class="params"><span class="function">   Int2Type&lt;Conservative&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first, ++result) </span><br><span class="line">        *result = *first;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fast routine-works only for pointers to raw data template &lt;typename InIt, typename OutIt&gt;</span></span><br><span class="line"><span class="function">OutIt <span class="title">CopyImpl</span><span class="params">(InIt first, InIt last, OutIt result,</span></span></span><br><span class="line"><span class="params"><span class="function">   Int2Type&lt;Fast&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> n = last-first;</span><br><span class="line">    <span class="built_in">BitBlast</span>(first, result, n * <span class="built_in"><span class="keyword">sizeof</span></span>(*first)); </span><br><span class="line">    <span class="keyword">return</span> result + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line"><span class="function">OutIt <span class="title">Copy</span><span class="params">(InIt first, InIt last, OutIt result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> TypeTraits&lt;InIt&gt;::PointeeType SrcPointee; </span><br><span class="line">    <span class="keyword">typedef</span> TypeTraits&lt;OutIt&gt;::PointeeType DestPointee; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> copyAlgo =</span><br><span class="line">        TypeTraits&lt;InIt&gt;::isPointer &amp;&amp; </span><br><span class="line">        TypeTraits&lt;OutIt&gt;::isPointer &amp;&amp; </span><br><span class="line">        TypeTraits&lt;SrcPointee&gt;::isStdFundamental &amp;&amp; </span><br><span class="line">        TypeTraits&lt;DestPointee&gt;::isStdFundamental &amp;&amp; </span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(SrcPointee) == <span class="built_in"><span class="keyword">sizeof</span></span>(DestPointee) ? Fast :</span><br><span class="line">                Conservative &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CopyImpl</span>(first, last, result, Int2Type&lt;copyAlgo&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 Copy 本身没做多少事，有趣的是函数内部的部分，枚举值 <code>copyAlgo</code> 用来选择哪一种实现。逻辑如下：如果两个迭代器是指针，如果两个指向的类型都是基础的，或者如果两个指向的类型 size 相同，那么我们可以使用 <code>BitBlast</code> 。最后一种情况是一种有趣的变形，如果我们这么做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1 = ...;</span><br><span class="line"><span class="keyword">int</span>* p2 = ...;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>* p3 = ...;</span><br><span class="line"><span class="built_in">Copy</span>(p1, p2, p3);</span><br></pre></td></tr></table></figure>
<p>这时 Copy  会也应该调用快速版本，即使源类型和目标类型不同。</p>
<p><code>Copy</code> 的缺点是它没法加速所有可以加速的东西。比如，我们可能有一个 C 结构，它内部只包含了基本类型数据，即所谓的 <em>plain old data</em> ，或者 POD 结构。C++ 标准允许 POD 结构的按位拷贝，但是 Copy 函数不能检测它是 POD，所以它会使用运行慢的版本。这里我们不但需要依赖 <code>TypeTraits</code>，也需要依赖一些传统的 traits。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">SupportsBitwiseCopy</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> result = TypeTraits&lt;T&gt;::isStdFundamental &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InIt, <span class="keyword">typename</span> OutIt&gt;</span><br><span class="line"><span class="function">OutIt <span class="title">Copy</span><span class="params">(InIt first, InIt last, OutIt result,</span></span></span><br><span class="line"><span class="params"><span class="function">   Int2Type&lt;<span class="literal">true</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> TypeTraits&lt;InIt&gt;::PointeeType SrcPointee; </span><br><span class="line">    <span class="keyword">typedef</span> TypeTraits&lt;OutIt&gt;::PointeeType DestPointee; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> useBitBlast =</span><br><span class="line">        TypeTraits&lt;InIt&gt;::isPointer &amp;&amp; </span><br><span class="line">        TypeTraits&lt;OutIt&gt;::isPointer &amp;&amp; </span><br><span class="line">        SupportsBitwiseCopy&lt;SrcPointee&gt;::result &amp;&amp; </span><br><span class="line">        SupportsBitwiseCopy&lt;DestPointee&gt;::result &amp;&amp; </span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(SrcPointee) == <span class="built_in"><span class="keyword">sizeof</span></span>(DestPointee) &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CopyImpl</span>(first, last, Int2Type&lt;useBitBlast&gt;); &#125;</span><br></pre></td></tr></table></figure>
<p>现在，想要接触 POD 类型无法使用 <code>BitBlast</code> 的束缚，我们只需要特化 <code>SupportBitwiseCopy</code> 并放进去一个 <code>true</code>;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">SupportsBitwiseCopy</span>&lt;</span>MyType&gt; &#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> result = <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>[The C++ in-depth series] Alexandrescu, Andrei_Meyers, Scott_Vlissides, John - Modern C++ design_ generic programming and design patterns applied (2001_2011, Addison-Wesley Professional) </li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/chmm/p/7469618.html">C++之局部类</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Jason Zeng, Anita Xiong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jason24-zeng.github.io/2023/02/04/C-%E6%8A%80%E5%B7%A7/">https://jason24-zeng.github.io/2023/02/04/C-技巧/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Coding-Technique/">Coding Technique</a></div><div class="post_share"><div class="social-share" data-image="/img/C-usable-example/C.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat/微信"/></a><div class="post-qr-code-desc">wechat/微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay/支付宝"/></a><div class="post-qr-code-desc">alipay/支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/23/python-framework-poetry/"><img class="prev-cover" src="/img/python_poetry.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Python Project Management - poetry (I)</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/12/Build-Bazel-WORKSPACE-%E5%AD%A6%E4%B9%A0/"><img class="next-cover" src="/img/C-usable-example/C.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Bazel WORKSPACE 学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/03/15/C-usable-example/" title="C++ usable example"><img class="cover" src="/img/C-usable-example/C.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-15</div><div class="title">C++ usable example</div></div></a></div><div><a href="/2022/05/08/C-Standard-Library/" title="C++ Standard Library"><img class="cover" src="/img/C-usable-example/C.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-08</div><div class="title">C++ Standard Library</div></div></a></div><div><a href="/2022/08/03/CMake-Intro-I/" title="Cmake-Intro-I -- CMakeLists.txt"><img class="cover" src="/img/C-usable-example/C.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-03</div><div class="title">Cmake-Intro-I -- CMakeLists.txt</div></div></a></div><div><a href="/2022/01/23/Effective-C-II/" title="Effective C++ (II)"><img class="cover" src="/img/Effective-C-II/effective_cplusplus_top.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">Effective C++ (II)</div></div></a></div><div><a href="/2022/01/24/Effective-C-III/" title="Effective C++ (III)"><img class="cover" src="/img/Effective-C-II/effective_cplusplus_top.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">Effective C++ (III)</div></div></a></div><div><a href="/2022/03/24/Effective-C-IV/" title="Effective C++ (IV)"><img class="cover" src="/img/Effective-C-II/effective_cplusplus_top.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">Effective C++ (IV)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/kobe.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jason Zeng, Anita Xiong</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">69</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">26</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Jason24-Zeng/" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:z5zeng@eng.ucsd.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/img/wechat_link.jpeg" target="_blank" title="Wechat"><i class="fab fa-weixin"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%8A%80%E5%B7%A7"><span class="toc-number">1.</span> <span class="toc-text">C++ 技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#P2-%E7%BC%96%E8%AF%91%E6%9C%9F-Assertions%EF%BC%88%E6%96%AD%E8%A8%80%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">P2 编译期 Assertions（断言）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P0-%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">P0 模板偏特化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1-%E5%B1%80%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">P1 局部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1-%E5%B0%86%E5%AE%9E%E5%B8%B8%E6%95%B0%E6%98%A0%E5%B0%84%E6%88%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">P1 将实常数映射成类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1-%E7%B1%BB%E5%9E%8B%E5%88%B0%E7%B1%BB%E5%9E%8B-Type2Type-%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.</span> <span class="toc-text">P1 类型到类型 Type2Type 的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2-%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="toc-number">1.6.</span> <span class="toc-text">P2 类型选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P1-%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E6%A3%80%E6%B5%8B%E5%8F%AF%E8%BD%AC%E5%8C%96%E6%80%A7%E5%92%8C%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">1.7.</span> <span class="toc-text">P1 在编译期检测可转化性和继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2-%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8E-type-info-%E7%9A%84%E5%A4%96%E8%A6%86%E7%B1%BB%EF%BC%88wrapper%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">P2 一个关于 type_info 的外覆类（wrapper）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2-NullType-%E5%92%8C-EmptyType"><span class="toc-number">1.9.</span> <span class="toc-text">P2 NullType 和 EmptyType</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P0-Type-Traits"><span class="toc-number">1.10.</span> <span class="toc-text">P0 Type Traits</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8C%87%E9%92%88-traits"><span class="toc-number">1.10.1.</span> <span class="toc-text">实现指针 traits</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.2.</span> <span class="toc-text">检测基础类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.3.</span> <span class="toc-text">优化的参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4-strip-%E8%A3%85%E9%A5%B0%E8%AF%8D"><span class="toc-number">1.10.4.</span> <span class="toc-text">去除 strip 装饰词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TypeTraits"><span class="toc-number">1.10.5.</span> <span class="toc-text">使用 TypeTraits</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">2.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/MMU-%E5%95%86%E5%93%81%E6%A3%80%E7%B4%A2Tech-Design/" title="MMU - 商品检索Tech Design"><img src="/img/MMU-%E8%A7%86%E9%A2%91%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%86%E5%88%AB/entire_workflow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MMU - 商品检索Tech Design"/></a><div class="content"><a class="title" href="/2023/03/19/MMU-%E5%95%86%E5%93%81%E6%A3%80%E7%B4%A2Tech-Design/" title="MMU - 商品检索Tech Design">MMU - 商品检索Tech Design</a><time datetime="2023-03-19T14:49:05.000Z" title="Created 2023-03-19 22:49:05">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/MMU-%E8%A7%86%E9%A2%91%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%86%E5%88%AB/" title="MMU - 视频关键帧与商品识别"><img src="/img/MMU-%E8%A7%86%E9%A2%91%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%86%E5%88%AB/entire_workflow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MMU - 视频关键帧与商品识别"/></a><div class="content"><a class="title" href="/2023/03/19/MMU-%E8%A7%86%E9%A2%91%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8E%E5%95%86%E5%93%81%E8%AF%86%E5%88%AB/" title="MMU - 视频关键帧与商品识别">MMU - 视频关键帧与商品识别</a><time datetime="2023-03-19T14:37:39.000Z" title="Created 2023-03-19 22:37:39">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E7%AB%99%E5%86%85%E5%95%86%E5%93%81%E6%B3%9B%E5%8C%96/" title="站内商品泛化"><img src="/img/%E7%AB%99%E5%86%85%E5%95%86%E5%93%81%E6%B3%9B%E5%8C%96/entire_workflow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="站内商品泛化"/></a><div class="content"><a class="title" href="/2023/03/19/%E7%AB%99%E5%86%85%E5%95%86%E5%93%81%E6%B3%9B%E5%8C%96/" title="站内商品泛化">站内商品泛化</a><time datetime="2023-03-19T11:35:43.000Z" title="Created 2023-03-19 19:35:43">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/Instagram-%E8%A7%86%E9%A2%91%E6%8C%82%E8%BD%A6%E5%95%86%E5%93%81/" title="Instagram 视频挂车商品"><img src="/img/Instagram-%E8%A7%86%E9%A2%91%E6%8C%82%E8%BD%A6%E5%95%86%E5%93%81/entire_workflow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Instagram 视频挂车商品"/></a><div class="content"><a class="title" href="/2023/03/19/Instagram-%E8%A7%86%E9%A2%91%E6%8C%82%E8%BD%A6%E5%95%86%E5%93%81/" title="Instagram 视频挂车商品">Instagram 视频挂车商品</a><time datetime="2023-03-19T08:54:27.000Z" title="Created 2023-03-19 16:54:27">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/09/Python-Project-Management-poetry-IV/" title="Python Project Management - poetry (IV)"><img src="/img/python_poetry.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python Project Management - poetry (IV)"/></a><div class="content"><a class="title" href="/2023/03/09/Python-Project-Management-poetry-IV/" title="Python Project Management - poetry (IV)">Python Project Management - poetry (IV)</a><time datetime="2023-03-09T14:55:58.000Z" title="Created 2023-03-09 22:55:58">2023-03-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/C-usable-example/C.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Jason Zeng, Anita Xiong</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">follow your heart</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
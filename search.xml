<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Effective C++ (II)</title>
      <link href="/2022/01/23/Effective-C-II/"/>
      <url>/2022/01/23/Effective-C-II/</url>
      
        <content type="html"><![CDATA[<h4 id="前言">前言</h4><p>一个月前，因为工作调动原因，有了充分的时间去拜读 C++ 相关书籍，于是决心从 <em>effetive C++</em> 开始，通过简单得学习了前 8 个条款，感觉自己茅塞顿开，发现自己之前工作中的许多不愉快都源于自己的代码习惯不够好。希望自己能在入职前，将这本工程师必读之作整体拜读一次，并以博客代替日记的方式记录下来，以备未来回顾。</p><h4 id="Item-09-不要再构造函数与析构函数中调用虚函数">Item 09. 不要再构造函数与析构函数中调用虚函数</h4><p><strong>Never call virtual functions during construction or destruction</strong></p><p>使用 C++ 时，不要在这两个函数中调用 virtual 函数，否则可能会得到预想以外的结果。这时 C++ 与 Java 或 C# 的区别。</p><p>下面有一个看似合理，实则反直观的例子，来解释这种行为的不合理性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个 base class, 创建交易对象，同时调用函数记录日志</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">// base 中的日志记录接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>();                        <span class="comment">// base 构造函数中调用 virtual 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span> :</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 继承类 BuyTransaction 内定义的日记函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span> :</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// 继承类 SellTransaction 内定义的日记函数</span></span><br><span class="line">    ...                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这上面的函数继承构造看似合理，但如果我们初始化一个 <code>BuyTransaction</code> 对象，就会发现问题了。初始化构造继承类对象时，基类对象的成分会首先构造妥当，这个行为发生在继承类单独成分构造之前。而基类 <code>Transaction</code> 构造时会调用 <code>logTransaction</code> 函数，且被调用的是 <code>Transaction</code> 中的版本，而非 <code>BuyTransaction</code> 中的版本。导致我们如上初始化的 <code>BuyTransaction</code> 对象表现与基类一样。也就这样理解，在 base class 构造期间，virtual 函数并非 virtual 函数。</p><p>而这种先完全构造好 base class 的行为也是合理的：如果基类初始化时调用了继承类的成员，而这些成员未初始化，则大大增加了不确定性。</p><p>唯一能避免上面的情况的做法就是，确定我们构造函数与析构函数都没有调用 virtual 函数，且它们调用的所有函数也服从这一约束–不调用 virtual 函数。</p><p>那上面这个问题怎么解决呢？也就是如何保证对象创建时能有正确版本的 <code>logTransaction</code> 函数被调用？</p><p>一种做法是，虽然我们没办法把使用 <code>virtual</code> 函数从基类向下调用，但是可以<em>让继承类向上传递足够信息给基类构造函数</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(<span class="keyword">const</span> std::string&amp; logInfo)</span> <span class="keyword">const</span></span>; <span class="comment">// non-virtual</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="keyword">const</span> std::string&amp; logInfo) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(parameters) : <span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>(parameters)) </span><br><span class="line">    &#123;...&#125;    \\ 将 log 信息传给基类构造函数</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::string <span class="title">createLogString</span><span class="params">(parameter)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到<code>private static</code> 的用法。比起使用成员初值列 (member initialization list) 的基类初始化方法，利用辅助函数传递值给基类的方法更方便。且此函数为 <code>static</code>，就保证了在基类初始化时指向的继承类成员变量是已经初始化好了的。</p><h4 id="Item-10-令赋值操作符返回一个-this-的引用">Item 10. 令赋值操作符返回一个 *this 的引用</h4><p><strong>Have assignment operators return a reference to *this</strong></p><p>在赋值时，对于所有内置类型以及 STL 库中提供的类型如 <code>string</code>, <code>vector</code>,<code>complex</code>, <code>tr1::shared_ptr</code>等，我们发现 C++   可以满足连续赋值的形式，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>为了实现这样的连续赋值，赋值操作符需要返回一个指向操作符左边实参的引用，这时一个我们在为 classes 实现赋值操作时应该遵守的协议：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 返回指向当前对象的引用</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不仅标准赋值形式适用，还适用于所有赋值相关运算</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，这个协议不是强制的，因此，即使不遵守，在编译时也能通过，但是因为几乎所有标准类型都遵守这个协议，所以建议在自己定义的时候也遵守。</p><h4 id="Item-11-在-operator-操作符里面处理自赋值">Item 11. 在 <code>operator=</code> 操作符里面处理自赋值</h4><p><strong>Handle assignment to self in operator=</strong></p><p>自赋值，或者自我赋值，是指对象被赋值给自己，典型的场景有如下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象，赋值给自己</span></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 i = j 时，自我赋值</span></span><br><span class="line">a[i] = a[j];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 px 与 py 指向同一个东西</span></span><br><span class="line">*px = *py;</span><br></pre></td></tr></table></figure><p>这些不明显的自赋值现象，都是 alias 别名带来的结果。一般来说，如果某段代码操作指针或者引用，而它们又被用来&quot;指向多个想同类型的对象&quot;时，就可能出现指向同一个对象的情况。</p><h5 id="自赋值陷阱例子">自赋值陷阱例子</h5><p>如果遵循后面要提到的 Item 13 与 Item 14，我们会运用对象来管理资源，且可以确定资源管理对象在 copy 发生时有正确的行为。此时，赋值操作符自赋值也许是安全的。但是，如果尝试自行管理资源（写一个用于资源管理的 class 时），我们就可能掉进在停止使用资源之前意外释放资源的情况。文中举了一个这样的例子，我们建立一个 class 来保存一个指针，该指针指向一块动态分配的 bitmap：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要实现一个 <code>operator=</code>赋值操作符，去更新位图</p><h5 id="Version-1">Version 1</h5><p>最初始的版本，貌似合理，但是如果 *this 和 rhs 是同一个对象，则可能出现问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb); <span class="comment">// 可能会因为自赋值而报错</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Version-2">Version 2</h5><p>修改版本，先判断是否自赋值，再执行。这个保证了自我赋值是安全的，但是如果 <code>new Bitmap</code> 导致异常，会产生一个指向被删除 <code>Bitmap</code> 的指针，我们无法安全删除，也无法安全读取，因此这一版本的 <code>operator=</code> 不具备异常安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb); <span class="comment">// 可能会因为自赋值而报错</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Version-3">Version 3</h5><p>把焦点放在异常安全性上，因为当 <code>operator=</code> 具备异常安全性时，它自然就具备了自赋值安全性。如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb); <span class="comment">// copy assignment;</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意，自赋值的时候，依然需要复制一份原来的值，可能不高效。可以考虑使用 Version 2 的方法加入一个 identity test，但需要考察是否有必要，比如这种自赋值出现的频率是否能 cover 住新增控制流分支与代码的效率降低。</p><h5 id="Version-4">Version 4</h5><p>采用 copy and swap 技术，这个技术在 pb 文件的赋值操作中经常用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;     <span class="comment">// 交换 *this 和 rhs 数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 损失了函数的清晰性。</span></span><br></pre></td></tr></table></figure><h4 id="Item-12-复制对象的每一个成分">Item 12. 复制对象的每一个成分</h4><p><strong>Copy all parts of an object</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 书籍笔记 </tag>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alias Table Sampling</title>
      <link href="/2022/01/23/alias-table-sampling/"/>
      <url>/2022/01/23/alias-table-sampling/</url>
      
        <content type="html"><![CDATA[<h3 id="离散按概率随机抽样算法-Alias-method">离散按概率随机抽样算法 - Alias method</h3><p>因为最近学习图嵌入 graph embedding 的相关操作与算法，发现无论在使用 deepwalk, LINE, node2vec 还是 SDNE 等图嵌入方法时，随机游走选择下一个节点都会用到一种按概率采样的方法，也就是 Alias 方法。第一次学习到这个算法，是在转专业刷知乎是看到的，想来也是很奇妙，果然有些优秀的算法容易被人提起并记住。这种方法因为其 $O(1)$ 的时间复杂度，大幅加速了候选集的生成。接下来的章节将主要讲解一些相关的随机抽样算法，最后再讲到 Alias method。</p><h4 id="问题阐述">问题阐述</h4><p>假设候选集为 $M$ 个事件，用 $1, … ,m$ 对这些时间编号。这些事件互斥，发生的概率为 $p_i, i = 1, …, m$，满足 $\sum^m_{i = 1} p_i = 1$。问，如何产生一个事件发生器，根据发生概率去产生事件呢？</p><h4 id="Solution-1：preSum-方法">Solution 1：preSum 方法</h4><p>步骤：</p><ul><li><p>通过数组 $p_i$ 依照前缀和方法生成 prefix Sum 数组 <code>presum</code>。亦将概率密度函数&quot;积分&quot;成概率分布函数</p></li><li><p>产生 0 - 1 的随机数，判断随机数处于哪个概率区间，返回对应的事件。</p></li></ul><p>复杂度分析：</p><ul><li><p>时间复杂度: 产生 <code>presum</code> 数组 $O(n)$，返回随机事件使用二分法 $(O(logn))$</p></li><li><p>空间复杂度：维护 <code>presum</code> 数组 $O(n)$</p></li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">preSum_method</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">float</span>&gt; presum;</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">eng</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">distr</span><span class="params">(FLOAT_MIN, FLOAT_MAX)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">preSum_method</span>(vector&lt;<span class="keyword">float</span>&gt;&amp; prob) &#123;</span><br><span class="line">        presum.<span class="built_in">reserve</span>(prob.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0.0f</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != prob.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            presum[i + <span class="number">1</span>] = presum[i] + prob[i];    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">generate_case</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = presum.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> random_num = <span class="built_in">distri</span>(eng);</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (random_num &lt; nums[mid + <span class="number">1</span>] &amp;&amp; random_num &gt;= nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random_num &gt;= nums[mid + <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Solution-2-预设候选集法">Solution 2 : 预设候选集法</h4><p>步骤，</p><ul><li><p>根据概率生成一个很大的候选集</p></li><li><p>通过随机数的值返回对应候选集位置的事件</p></li></ul><p>复杂度分析：</p><ul><li><p>产出候选集的时间复杂度 $O(N)$，$N$ 与精度有关，返回随机事件 $O(1)$</p></li><li><p>空间复杂度 $O(N)$</p></li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CandidateSet</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; candidate_set;</span><br><span class="line">    <span class="keyword">int</span> P;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CandidateSet</span>(vector&lt;<span class="keyword">float</span>&gt;&amp; prob, <span class="keyword">int</span> precision) &#123;</span><br><span class="line">        P = <span class="number">10</span> ** precision;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != prob.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(i, (<span class="keyword">int</span>) (i * P))</span></span>;</span><br><span class="line">            std::<span class="built_in">copy</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), std::<span class="built_in">back_insert</span>(candidate_set));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">generate_case</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random_number = <span class="built_in">rand</span>() % P;</span><br><span class="line">        <span class="keyword">return</span> candidate_set[random_number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法主要的弊端在于需要申请很大一块连续空间来存储候选集。</p><h4 id="Solution-3-Alias-Method">Solution 3 : Alias Method</h4><p>本文的重点。主要的创新点在于建表环节。我们考虑到等概率抽样的时间复杂度为 $O(1)$，而对二项分布的时间进行抽样的时间复杂度也是 $O(1)$。因此，整个时间的思路变成了如何把依概率抽样的时间转变为等概率抽样。</p><p>alias method 考虑维护一个 alias 表，里面有 $M$(事件个数) 个值得数组，对数组中的每个元素，是一个二项分布参数的三元组<code>prob, lower_event, higher_event</code>。通过等概率选取数组的元素，再依概率选择二元事件，我们就可以完成依概率对多元事件的抽样。</p><p>步骤：</p><ul><li><p>制表。两张表：</p><ul><li><p>等概率表，大小为 $M$</p></li><li><p>维护两个队列，small, large 分别存放小于 1 和 大于 1 的时间下标</p></li><li><p>每次从 small，large 中各取一个，用 large 里的值填补 small 的，使 small 的整体概率等于 1，然后根据 large 剩余的整体概率，将元素重新放回 large 或 small 中。</p></li><li><p>所有的概率都等于 1</p></li></ul></li><li><p>采样</p></li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AliasMethod</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; alias_method;</span><br><span class="line">    <span class="keyword">int</span> multiplier;</span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">eng</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">distr</span><span class="params">(FLOAT_MIN, FLOAT_MAX)</span></span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CandidateSet</span>(vector&lt;<span class="keyword">float</span>&gt;&amp; prob, <span class="keyword">int</span> precision) &#123;</span><br><span class="line">        std::queue&lt;<span class="keyword">int</span>&gt; large, small;</span><br><span class="line">        multiplier = prob.<span class="built_in">size</span>();</span><br><span class="line">        alias_method.<span class="built_in">reserve</span>(multiplier);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != multiplier; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_prob = prob[i] * multiplier;</span><br><span class="line">            <span class="keyword">if</span> (new_prob &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                small.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new_prob &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                large.<span class="built_in">push</span>(i)</span><br><span class="line">            &#125;</span><br><span class="line">            alias_method[i] = new_prob == <span class="number">1</span> ? &#123;new_prob, i&#125; : &#123;new_prob, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!large.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> large_pos = large.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">int</span> small_pos = small.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">auto</span>&amp; l = alias_method[large_pos];</span><br><span class="line">            large.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span>&amp; s = alias_method[small_pos];</span><br><span class="line">            small.<span class="built_in">pop</span>();</span><br><span class="line">            l.first -= s.first;</span><br><span class="line">            s.second = large_pos;</span><br><span class="line">            <span class="keyword">if</span> (l.first &lt; <span class="number">1</span>) small.<span class="built_in">push</span>(large_pos);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l.first &gt; <span class="number">1</span>) large.<span class="built_in">push</span>(large_pos);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">generate_case</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> random_case = <span class="built_in">rand</span>() % multiplier;</span><br><span class="line">        <span class="keyword">float</span> random_num = <span class="built_in">distri</span>(eng);</span><br><span class="line">        <span class="keyword">auto</span>&amp; temp = alias_method[random_case];</span><br><span class="line">        <span class="keyword">return</span> temp.first &lt;= random_num ? random_case : temp.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Probability </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Probability </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding Introduction (VI)</title>
      <link href="/2022/01/22/Embedding-Introduction-VI/"/>
      <url>/2022/01/22/Embedding-Introduction-VI/</url>
      
        <content type="html"><![CDATA[<h4 id="SDNE-Structural-Deep-Network-Embedding">SDNE : Structural Deep Network Embedding</h4><p>DeepWalk, LINE, Node2vec 这几个 Graph Embedding  的方法，在训练 Embedding 的时候使用的都是 skip-gram 的模型结构。这个模型结构只有一层隐藏层，很难学到一些高阶非线性的特征。而 SDNE 为了表达高阶非线性，引入了更深的网络结构。</p><h4 id="训练网络结构">训练网络结构</h4><p>SDNE 使用的训练框架是一种半监督式的深度模型训练框架。其整体的网络结构如下：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-VI/SDNE_top.png" alt="SDNE_framework"></p><p>首先搞清楚一边的深层网络结构 ： Autoencoder</p><h5 id="Autoencoder-for-second-order-proximity">Autoencoder for second-order proximity</h5><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-VI/autoencoder.png" alt="SDNE_autoencoder"></p><p>如上图，为一个 autoencoder 的基本结构。我们自下往上的看。</p><p>输入层 $x_i \in R^{|V|}$ ， $|V|$ 为所有节点的数量。如果 $(i, j)$ 边存在，则 $x_{ij} &gt; 0$，可以理解为 $x_{ij} = w_{ij}$ 为 edge $(i,j)$ 的边权，否则，$x_{ij} = 0$。</p><p>紫色部分是 encoder，是将稀疏向量 $x_i$ 降维，使之稠密的过程。</p><p>中间蓝色部分就是每个顶点 $i$ 对应的输出 embedding $y_i^{(K)}$ 。</p><p>深蓝色部分则是 decoder，可以认为是紫色部分的 revert，升维，使之稀疏，最终输出向量 $\hat{x_i}$。</p><p>整个 autoencoder 的过程是无监督的。在迭代过程中，我们需要计算输入向量 $x_i$ 与向量 $\hat{x_i}$ 的 loss，认为是二阶近邻关系的目标函数表达。</p><p>这个 loss 表示为：</p><p>$$<br>\begin{aligned}<br>\mathcal{L}_{2nd} &amp;=  \sum^n_i |(\mathbf{\hat{x}}_i - \mathbf{x}_i) \bigodot  \mathbf{b}_i|^2_2  \\<br>&amp;= |(\hat{X}_i - X_i) \bigodot  B |^2_F<br>\end{aligned}<br>$$</p><p>其中 $\bigodot$ 表达 Hadamard 乘积，即按位置相乘之和。如果 $s_{i,j} = 0$，则 $b_{i,j} = 1$。否则 $b_{i,j} = \beta &gt; 1$。因此，通过将临接矩阵 $S$作为输入，使用修改的深层 autoencoder，有相似邻居结构的顶点会在表达空间 embedding 中靠近。</p><h5 id="Supervised-component-for-first-order-proximity">Supervised component for first-order proximity</h5><p>除了 global 的网络结构，我们也需要抓住局部结构，这里的局部结构在文中专指 first-order proximity。损失函数可从网络图中得到：</p><p>$$<br>\begin{aligned}<br>\mathcal{L}_{1st} &amp;= \sum^n_{i,j = 1} s_{i,j}|y^{K}_i - y^{K}_j|^2_2\\<br>&amp;= \sum^n_{i,j = 1} s_{i,j}|y_i - y_j|^2_2<br>\end{aligned}<br>$$</p><p>(这里出现 markdown 与 mathjax 对 _ 的转义出现冲突，导致数学公式显示有问题。需要再 _ 前加下划线解决。)</p><p>这个损失函数表征的是，如果两个节点相连，则存在一定的相似性，如果权重越大，相似性越高。公式中的 $y$ 表示自编码器的中间层输出。</p><h5 id="整个模型损失函数">整个模型损失函数</h5><p>整个模型的损失函数结合了一阶和二阶 proximity 相关的目标函数，同时引入了一个正则项：</p><p>$$<br>\mathcal{L}_{reg} = \frac{1}{2}\sum^K_{k = 1}(|W^{(k)} |^2_F + |\hat{W}^{(k)} |^2_F)<br>$$</p><p>其中 $W^{(k)}$ 与 $\hat{W}^{(k)}$ 分别代表自编码器中 encoder 和 decoder 网络的权重。</p><p>整体损失函数如下：</p><p>$$<br>\begin{aligned}<br>\mathcal{L}_{mix} &amp;= \mathcal{L}_{2nd} + \alpha\mathcal{L}_{1st} + \mu\mathcal{L}_{reg} \\<br>&amp;= |(\hat{X}_i - X_i) \bigodot  B |^2_F + \alpha \sum^n_{i,j = 1} s_{i,j}|y_i - y_j|^2_2 + \mu\mathcal{L}_{reg}<br>\end{aligned}<br>$$</p><p>这个损失函数在实验效果上明显由于 LINE，但是因为网络结构更加复杂，输入输出中又分厂稀疏，因此时间复杂度较高，是一个优化的方向。</p><h4 id="Reference-2">Reference</h4><p><a href="https://www.kdd.org/kdd2016/papers/files/rfp0191-wangAemb.pdf">Structural Deep Network Embedding</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Graph Embedding </tag>
            
            <tag> SDNE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding Introduction (V)</title>
      <link href="/2022/01/21/Embedding-Introduction-V/"/>
      <url>/2022/01/21/Embedding-Introduction-V/</url>
      
        <content type="html"><![CDATA[<h3 id="DeepWalk-的优化-Node2Vec">DeepWalk 的优化 - Node2Vec</h3><p>可以这么理解，deepwalk 主要是基于 DFS 邻域的 graph embedding 算法，而 LINE 则是基于 BFS 邻域的 graph embedding 算法。接下来介绍的 node2vec 则是总和考虑 DFS 与 BFS 的 graph embedding 算法，是结合 DFS 与 BFS 的随机游走的 deep walk。</p><h4 id="算法原理">算法原理</h4><p>定义：</p><ol><li><p>$f(u)$ 为顶点 $u$ 到其对应 embedding 向量的映射</p></li><li><p>$N_S(u)$ 为在采样策略 $S$ 下顶点 $u$ 的近邻顶点集合</p></li></ol><p>而 node2vec 优化的目标比较直接，就是希望找到最优映射 $f(u)$，使近邻顶点出现的概率最大化，即</p><p>$$<br>max_f\sum_{u \in V} \log Pr(N_s(u) | f(u))<br>$$</p><p>为了使该最优化问题可解，文章做了两个假设：</p><ol><li><p>条件独立性假设。即在给定顶点 $u$ 下，其近邻顶点出现的概率，与近邻集合中其他顶点无关。即</p><p>$$<br>Pr(N_s(u) | f(u)) = \prod_{n_i\in N_s(u)} Pr(n_i | f(u))<br>$$</p></li><li><p>特征空间对称性假设。与 LINE 不同，假设一个顶点无论是作为原顶点还是近邻顶点，其共享同一套 embedding 向量。对应表达为</p><p>$$<br>Pr(n_i | f(u)) = \frac{\exp(f(n_i)\cdot f(u))}{\sum_{v\in V} \exp(f(v)\cdot f(u))}<br>$$</p></li></ol><p>最终，根据假设条件，我们的最终目标函数表示为</p><p>$$<br>max_f\sum_{v\in V}\left[-\log Z_u + \sum_{n_i\in N_s(u)} f(n_i) \cdot f(u)\right]<br>$$</p><p>其中 $Z_u = \sum_{n\in N_s(u)} \exp(f(n_i)\cdot f(u))$ 的计算代价高，需要采用负采样技术进行优化。</p><h4 id="采样策略">采样策略</h4><p>相比随机游走 deep walk 中的采样方式， node2vec 也是随机游走，但是是一种依概率随机游走，这种随机游走是有偏的。</p><p>比如给定当前顶点 $v$，访问下一个顶点 $x$ 的概率我们设定为</p><p>$$<br>P(c_i = x | c_{ - 1} = v) = \frac{\pi_{vx}}{Z} \text{, if } (v, x) \in E<br>$$</p><p>$$<br>P(c_i = x | c_{i - 1} = v) = 0  \text{, otherwise}<br>$$</p><p>其中 $\pi_{vx}$ 表示顶点 $v$  与顶点 $x$ 之间的转移概率（未 normalized）， $Z$ 则是归一化常数</p><p>文中 node2vec 引入两个参数 $p$ 与 $q$ 来控制随机游走的策略。</p><p>$$<br>\pi_{vx} = \alpha_{pq}(t, x)\cdot w_{vx}<br>$$</p><p>其中 $w_{vx}$ 表示顶点 $v$ 与 $x$ 之间的边权。而 $\alpha_{pq}$ 则与上一次游走起点 $t$ 和当次游走终点 $x$ 有关，可知两个顶点的距离 $d_{tx}$ 可以有三个取值：</p><ul><li>$d_{tx} = 0$，即两点属于同一个点，此时设定 $\alpha_{pq}(t, x) = \frac{1}{p}$，所以 $p$ 又被称为 return parameter，表示马上重新访问原来 node 的可能性。</li><li>$d_{tx} = 1$，即 $t, x$ 与 $v$ 三点均相邻，此时设定 $\alpha_{pq}(t, x) = 1$</li><li>$d_{tx} = 2$，即 $x$ 远离 $t$ 点，两点不直接相邻，此时设定 $\alpha_{pq}(t, x) = \frac{1}{q}$，所以 $q$ 又被称为 in-out parameter。</li></ul><p>从解释中可以看出， $p, q$ 值的设定，描述了算法对 BFS 与 DFS random walk 的倾向性。具体的取值可以通过下图直观看出:</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-V/node2vec_pm.png" alt="node2vec_parameter"></p><h4 id="算法策略">算法策略</h4><p>采样顶点序列后，后续的方式与 deepwalk 与 LINE 一致，均通过 word2vec 的方法去学习 embedding 向量。node2vec 与 LINE 一样，是依概率抽取邻接点，同时采用 alias table 算法进行采样。</p><p>其核心算法伪代码如下：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-V/node2vec_algorithm.png" alt="node2vec_algorithm"></p><h4 id="Reference-3">Reference</h4><p><a href="https://www.kdd.org/kdd2016/papers/files/rfp0218-groverA.pdf">node2vec: Scalable Feature Learning for Networks</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Graph Embedding </tag>
            
            <tag> Node2Vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding-Introduction (IV)</title>
      <link href="/2022/01/21/Embedding-Introduction-IV/"/>
      <url>/2022/01/21/Embedding-Introduction-IV/</url>
      
        <content type="html"><![CDATA[<h4 id="LINE">LINE</h4><p>接 <a href="https://jason24-zeng.github.io/2022/01/20/Embedding-Introduction-III/">上一章节</a></p><p>我们已经定义好处理 LINE 的一阶与二阶 proximity 的目标函数，这一节主要是讨论函数的优化。</p><h4 id="模型优化">模型优化</h4><h6 id="回顾">回顾</h6><p>first-order proximity 目标函数</p><p>$$<br>O_1 = - \sum_{(i, j)\in E} w_{ij}\log p_1(v_i, v_j) \tag{1}<br>$$</p><p>second-order proximity 目标函数</p><p>$$<br>O_2 = - \sum_{(i, j)\in E} w_{ij} \log p_2(v_j|v_i) \tag{2}<br>$$</p><p>计算 second-order proximity 消耗较高，因为需要计算每个顶点的条件概率，然后把这些概率加和。为了解决这个消耗问题，文中采用了负采样的方法，通过每条边的一些噪音分布去采样多条负边。对边 $(i, j)$ 的目标函数变为：</p><p>$$<br>\log\sigma(\vec{u_j}^{1T} \cdot \vec{u_i}) + \sum^K_{i = 1} E_{v_n \sim P_n(v)}\left[\log\sigma(\vec{u}_n^{1T} \cdot \vec{u}_i)\right] \tag{3}<br>$$</p><p>其中，$\sigma(x) = 1 / (1 + \exp(-x))$ 是 sigmod 函数。前一项基于观察的边建模，后一项对从噪音分布采样得到的负边建模。$K$ 表示负边的总数。我们设定 $P_n(v) \propto d_v^{3/4}$，而 $d_v$ 为顶点 $v$ 的出度。</p><p>对于目标函数 $1$， 存在一个平凡解：$\forall i k, u_{ik} = \infty$。为了避免这个问题，我们依然使用方程 $3$ 中的负采样方法，只是把 $\vec{u_j}^{1T}$ 换成 $\vec{u_j}^{T}$ 即可。</p><p>为了最优化方程 $3$，文中采用了异步随机梯度算法（asynchronous stochastic gradient algorithm, ASGD）。每一步，ASGD 算法采样了一 mini-batch 的边，然后更新模型参数。如果一条边 $(i, j)$ 被采样，则梯度 (顶点 $i$ 的embedding 向量 $\vec{u_i}$) 会被使用一下方程计算</p><p>$$<br>\frac{\partial O_2}{\partial \vec{u_i}} = w_{ij}\cdot \frac{\partial \log p_2(v_j|v_i)}{\partial \vec{u_i}}<br>$$</p><p>这样的问题在于梯度会被乘以边权，当边权方差较大时，可能出现问题。</p><p>上面的问题主要出在对于不同的边权，固定的学习率不合适。所以一个简单的解决方法是将边权为 $w$ 的边 unfold 成 $w$ 条 0 - 1 边。这可以解决问题，但是会显著提升内存占用。文中的解决方法实际上是，将 $w$ 作为作为概率分布的权重，随机采样样本边，将取到的样本边作为 0 - 1 边去训练。这个想法与 XGBoost 中的直方图思想如出一辙。</p><p>而随机采样要达到空间时间上的最优还要考虑一些算法上的优化。我们假设 $W = (w_1, w_2, …, w_{|E|})$ 表示一系列边的权重，我们可以通过计算一个 $w_{sum} = \sum_{i = 1}^{|E|}$ 作为随机数的上界，判断这个随机数处于哪个区间，便能 sample 出边，这样的算法时间复杂度是 $O(|E|)$ ，在边很多的情况下时间花销较大。为了解决这个问题，可以考虑使用 <a href="https://blog.csdn.net/haolexiao/article/details/65157026">alias table 方法</a>，这个方法可以再 $O(1)$ 的时间复杂度下从固定的离散分布里根据权重筛选样本。</p><p>由此，我们可知，采样一条边需要 $O(1)$ 的时间复杂度，那么负采样优化后整体的时间花销为 $O(d(K + 1))$ ，$K$ 为负采样数量。因此，每一步迭代会花费 $O(dK)$ 次。而实际情况下，每次消耗的时间正比于边的数量 $|E|$。因此，LINE 的整体时间复杂度是 $O(dK|E|)$，与顶点数量无关。</p><h6 id="总结">总结</h6><p>从上面的理论推到可以看出，边的采样策略在不影响整体效果的前提下提升了随机梯度下降的效率。</p><h1></h1>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Graph Embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding Introduction (III)</title>
      <link href="/2022/01/20/Embedding-Introduction-III/"/>
      <url>/2022/01/20/Embedding-Introduction-III/</url>
      
        <content type="html"><![CDATA[<h3 id="Embedding-在互联网场景的使用-Graph-Embedding">Embedding 在互联网场景的使用 - Graph Embedding</h3><p>之前讲的 word2vec 和 item2vec 实际上都是在一个序列的基础上获得对象的隐式向量表达的。但是在互联网场景下，数据对象之前可能更多得呈现的是图结构，比如使用用户行为生成的物品全局关系图，或者物品属性知识图谱等。这种背景下，传统的序列 embedding 方法无法很好处理，因此，对图结构中节点进行表达的 graph embedding 便成了新的研究方向。随着大数据时代的到来，推荐系统愈发重要，这项技术也因此愈发受到重视。</p><h3 id="Graph-Embedding-早期方法-Deep-Walk">Graph Embedding 早期方法 - Deep Walk</h3><p>基于随机游走生成图结构对应的节点序列，是早期 Graph Embedding 的一种重要方法。其允许重复访问已访问节点，使用深度优先（DFS）进行序列生成。</p><p>其思路是，给定一个节点，通过随机采样的方法，获得该节点相邻节点中的一个，以此作为序列的下一个节点。重复上述步骤，知道序列长度达到预期长度。再使用 skip-gram word2vec 的方法表达向量。使用了 Hierachical Softmax 中构造 Huffman 树的技巧优化了 softmax 的时间复杂度</p><p>其伪代码表示为：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-III/fake_coding.png" alt="graph embedding deep walk algorithm"></p><p>使用随机游走的方法创建训练数据，这种方法的特点：</p><ul><li><p>可以实现机器、进程或线程维度的并行</p></li><li><p>适合动态更新，更新时只对新增节点增加</p></li></ul><p>该算法的超参数有：</p><ul><li><p>skip-gram 的窗口大小 $w$</p></li><li><p>生成向量的维度，隐藏层的神经元个数 $d$</p></li><li><p>每个节点的游走次数 $\gamma$</p></li><li><p>游走长度 $t$</p></li></ul><p>可认为 DeepWalk 是 Graph Embedding 的 baseline 方法。</p><p>参考：<a href="https://arxiv.org/pdf/1403.6652.pdf">DeepWalk: Online Learning of Social Representations</a></p><h3 id="Large-scale-Information-Network-Embedding-LINE">Large-scale Information Network Embedding (LINE)</h3><p>LINE 将非常大的信息网络映射到了低维向量空间（embedding）中，对可视化，节点分类等问题都有不错的效果。其相对 DeepWalk 这种纯粹随机游走的序列生成方式有以下两个特点：</p><ol><li><p>可以应用到有向图、无向图以及边有权重的网络</p></li><li><p>使用一阶、二阶的临近关系引入目标函数，从而使最终学出的 node embedding 的分布更加均匀平滑，避免 node embedding 聚集的情况发生</p></li><li><p>适用于大规模 network 上进行应用(Deep Walk 也适用)</p></li></ol><h4 id="问题定义">问题定义</h4><h5 id="Information-Network">Information Network</h5><p>$G = (V, E)$ 其中 $V$ 是 vertex 节点集合，$E$ 是 edge 边集合。定义 $e = (u, v) \in E$ 是一个有序的节点对，边权 $W_{uv} &gt; 0$。如果 $G$ 为无向图 (undirected graph)，则有 $(u, v) = (v, u)$ 与 $W_{uv} =  W_{vu}$。而如果 $G$ 为有向图 (directed graph)，那么有 $(u, v) \neq (v, u)$ 与 $W_{uv} \neq W_{vu}$</p><h5 id="First-order-Proximity-local-network-structure-一阶近邻关系">First-order Proximity (local network structure) 一阶近邻关系</h5><p>边权 $W_{uv}$ 就表示节点 $u$ 与 $v$ 之间的 first-order proximity。两个节点之间相连的边权重越高，则这两个点越相似。若两点之间没有边，则 first-order proximity 为 0</p><h5 id="Second-order-Proximity-global-netword-structure-二阶近邻关系">Second-order Proximity (global netword structure) 二阶近邻关系</h5><p>首先定义一个 $P_u = (W_{u,1},…, W_{u, |V|})$ 便是节点 $u$ 与其他所有节点的 first-order proximity 组成的集合。$u$ 与 $v$ 之间的相似度，则可以通过 $P_u$ 与 $P_v$ 之间的权重重合程度来决定相似度。两个节点的 neighbors 重复得越多，两者越相似。特别的，如果没有节点同时指向 $u$ 与 $v$ 或者 被 $u$ 与 $v$ 所指向，则 $u$ 与 $v$ 之间的 second-order proximity 为 0。</p><p>如下图的一个 Information Netword 的 toy model，可以看出 5 与 6 之间有较高的 second-order proximity，而 6 与 7 之间有较高的 first-order proximity。</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-III/line_information_network.png" alt="Information Network"></p><h5 id="Large-scale-Information-Network-Embedding">Large-scale Information Network Embedding</h5><p>使用一个低维向量去表示整个 Information Network，即学习一个函数：</p><p>$$<br>f_G : V \rightarrow R^d, where \ d \ll|V|<br>$$</p><h4 id="模型描述">模型描述</h4><p>如前面所说，一个好的 Information Network Embedding 既需要有 first-order proximity 的信息，也不能忽视 second-order proximity。</p><h5 id="考虑-first-order-proximity-进行建模">考虑 first-order proximity 进行建模</h5><p>对于每个无向边 $(i,j)$，我们可以定义点 $v_i$ 与 $v_j$ 的联合概率如下：</p><p>$$<br>p_1(v_i, v_j) = \frac{1}{1 + \exp(-\vec{u_i}^T\cdot\vec{u_j})} \tag{1}<br>$$</p><p>其中，$\vec{u_i}\in R^d$ 是节点 $v_i$ 的低维向量表达。方程 $1$ 定义了一个在空间 $V \times V$ 的分布函数，它的经验概率可以被定义为</p><p>$$<br>\hat{p_1}(i,j) = w_{ij}/W<br>$$</p><p>其中，</p><p>$$<br>W = {\sum_{(i, j)\in E} w_{ij}}<br>$$</p><p>为了维护 first-order proximity，一个直白的想法是最小化目标函数</p><p>$$<br>O_1 = d(\hat{p}_1(\cdot ,\cdot), p_1(\cdot ,\cdot)) \tag{2}<br>$$</p><p>其中 $d(\cdot ,\cdot)$ 为两个分布之间的距离，这个距离我们选择使用 KL 散度来表达，同时取出其中的常数项，我们就有：</p><p>$$<br>O_1 = - \sum_{(i, j)\in E} w_{ij}\log p_1(v_i, v_j) \tag{3}<br>$$</p><p>需要注意到 first-order proximity 只对无向图有用。通过找到集合 ${\vec{u_i}}_{i = 1…|V|}$ ，使方程 $3$目标函数最小化，我们可以在 $d$ 维空间中表示每个节点。</p><h5 id="考虑-second-order-proximity-建模">考虑 second-order proximity 建模</h5><p>second-order proximity 对有向图与无向图都可行。在考虑 second-order proximity  是，节点扮演了两个角色：</p><ul><li><p>节点本身</p></li><li><p>其他节点的上下文 context</p></li></ul><p>为了区分这两个角色，我们引入了两个向量 $\vec{u}_i$ 与 $\vec{u}'_i$，分别对应魔偶个节点 $v_i$ 的上述两种角色的表达。</p><p>首先我们定义一个上下文 $v_j$ 被 $v_i$ 产生的概率:</p><p>$$<br>p_2(v_j|v_i) = \frac{\exp(\vec{u}_i’^T \cdot \vec{u}_j)}{W(\vec{u}_j)} \tag{4}<br>$$</p><p>其中，</p><p>$$<br>W(\vec{u}_j) = \sum \exp(\vec{u}_k’^T \cdot \vec{u}_j)<br>$$</p><p>该方程实际定义了一个网络里所有节点为节点 $v_i$ context 的条件概率。如果 $p2(\cdot | v2)$ 与 $p2(\cdot | v1)$ 的概率分布相似，则这两个点的 second-order proximity 是相似的。</p><p>为了维护 second-order proximity，我们需要逼近经验分布函数 $\hat{p}_2(\cdot | v_i)$，因此，我们需要最小化一下目标函数</p><p>$$<br>O_2 = \sum_{i \in V} \lambda_i d(\hat{p}_2(\cdot|v_i), p_2(\cdot|v_i)) \tag{5}<br>$$</p><p>因为网络中每个节点的重要性不同，我们引入 $\lambda_i$ 表达网络中节点 $i$ 的优先级，它可以通过度数衡量 (需要进一步探讨，应该是图论中的出入度计算) 或者通过一些算法预估 (比如 PageRank)。</p><p>经验分布</p><p>$$<br>\hat{p_2} (\cdot \vert v_i) = w_{ij} / d_i<br>$$</p><p>其中 $w_{ij}$ 为边 $(i,j)$ 的权重， $d_i = \sum_{k\in N(i)}  w_{ik}$ 表示顶点 $i$ 的出度 (out-degree), $N(i)$ 则是节点 $v_i$ 的 out-neighbors。</p><p>在文章中，简单得将 $\lambda_i$ 设成顶点 $i$ 的度数，即 $\lambda_i = d_i$， 同时采用 KL 散度作为距离方程，同时去掉常数项，则最终我们目标函数变为</p><p>$$<br>O_2 = - \sum_{(i, j)\in E} w_{ij} \log p_2(v_j|v_i)<br>$$</p><p>通过学习集合 ${\vec{u_i}}_{i = 1…|V|} $ 与</p><p>$ {\vec{u_i}'}_{i = 1…|V|}$ 最小化目标，我们可以用一个 $d$ 维向量 $\vec{u_i}$ 表达每一个顶点。</p><h5 id="Combine-一阶与二阶-proximity">Combine 一阶与二阶 proximity</h5><p>文章中分别训练一阶 proximity 和 二阶 proximity，然后将得到的 embedding 拼起来作为该顶点的 embedding 表达。一个更原则性的方式是将目标函数联立起来求。</p><p>参考：<a href="https://arxiv.org/pdf/1503.03578.pdf">LINE: Large-scale Information Network Embedding</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Graph Embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding Introduction (II)</title>
      <link href="/2022/01/20/Embedding-Introduction-II/"/>
      <url>/2022/01/20/Embedding-Introduction-II/</url>
      
        <content type="html"><![CDATA[<h4 id="生成-Embedding-的方法-II">生成 Embedding 的方法 (II)</h4><h4 id="Item2Vec-Word2Vec-的衍生">Item2Vec : Word2Vec 的衍生</h4><p>Word2Vec 那种用向量 embedding 去表达单词的方法因其 state-of-art 的性能而在 NLP 领域备受关注。同样的，这种技术/技巧在 推荐系统领域也受到了追捧。特别的，通过使用 skip-gram using negative sampling 的 i2i 协同过滤(CF) 算法因为比肩 SVN CF 算法而受到推崇。这边博客，也主要讲解 Item2Vec 中的一些特点。</p><h4 id="Skip-gram-with-negative-sampling-SGNS">Skip-gram with negative sampling (SGNS)</h4><p>Reference: <a href="https://arxiv.org/pdf/1301.3781.pdf%C3%AC%E2%80%94%20%C3%AC%E2%80%9E%C5%93">Efficient estimation of word representations in vector space</a></p><p>SGNS 方法旨在找到单词的表达，使其能够抓住该单词与句子中周围单词的关系。</p><p>我们用 $(w_i)^K_{i = 1}$ 表示一批连续的单词，其中，这些词都来自于一个有限词汇集 $W = {w_i}^W_{i=1}$。 从而，我们可以表达 skip - gram 的目标，最大化：</p><p>$$<br>\frac{1}{K} \sum^K_{i = 1} \sum_{-c &lt;= j &lt;= c, j \neq 0} \log{p(w_{i + j} | w_i)} \tag{1}<br>$$</p><p>其中，$c$ 是上下文的窗口大小，该大小可能取决于 $w_i$。而 $p(w_{i + j} | w_i)$ 则是 softmax 函数：</p><p>$$<br>p(w_{i + j} | w_i) = \frac{\exp(u^T_iv_j)}{\sum_{k\in I_w}\exp(u^T_iv^T_k)}<br>$$</p><p>其中 $u_i\in U(\mathcal{R^m}) $ 和 $v_i \in V(\mathcal{R^m})$ 分别是 $w_i \in W$ 中关于目标和上下文表达的隐向量。$m$ 通常通过经验与数据集的大小去选择。使用 softmax 函数不太现实，因为计算 $\nabla p(w_{i + j} | w_i)$ 的时间复杂度是线性的，与词汇集的大小有关。</p><h5 id="负采样">负采样</h5><p>为了不大幅影响精度的情况下环节上述计算问题。我们将上面的 softmax 函数换成了</p><p>$$<br>p(w_{i + j} | w_i) = \sigma(u^T_iv_j)\prod^N_{k=1} \sigma(u^T_iv^T_k)<br>$$</p><p>其中，$\sigma(x) = \frac{1}{1 + \exp(-x)}$，$N$ 是一个决定每个正样本所需负例样本数的参数。而 $w_i$ 中的负样本原则概率通过一元模型函数（Unigram Distribution） $f(w_i)$ 的 $\frac{3}{4}$ 次方来获得。整个公式为：</p><p>$$<br>P(w_i) = \frac{f(w_i)^{3/4}}{\sum_{j = 0}^n(f(w_i)^{3/4})}<br>$$</p><p>这个一元函数实际上就是将样本中的所有词写到了一个数组中，重复的词重复写到数组的不同位置(使用每个单词的索引填充)，直接通过生成随机数的方式去返回该随机数对应位置的数。如此依赖，如果数组中出现次数多的数，被负采样的概率就更大。</p><p>使用 $\frac{3}{4}$ 次方，更多的是一种经验效果，好于单纯用一元函数模型。</p><h5 id="降采样">降采样</h5><p>除此以外，为了解决稀有与高频词的不平衡问题，文章中提出了一种降采样的方法。</p><p>已知一个输入词序列，我们以一个概率去丢弃每个词：</p><p>$$<br>p(discard | w) = 1 - \sqrt{\frac{\rho}{f(w)}}<br>$$</p><p>其中 $f(w)$ 为该词的词频，$\rho$ 为一个预设阈值。这个操作据报道能提升训练进程，并大幅提升稀有词的表达。</p><p>以上就是<strong>SGNS</strong> 的两大操作 负采样 与 降采样。</p><h4 id="Item2Vec-思路">Item2Vec 思路</h4><p>SGNS 方法被使用到了 item-based 的协同过滤推荐系统中。有些场景，我们没办法达到用户与一系列商品之间的关联信息，这时候，通过商品侧做的协同过滤就尤为重要。使用 SGNS 的想法也很显然，只要我们把一集合的商品认为是一序列的单词，则使用 embedding 去获得商品间的相关性与获得单词之间的相关性就并无不同。</p><p>从序列到集合后，时空信息就丢失了，也就是丢掉了它们之间的相邻关系。而 Item2Vec 就考虑丢掉这部分信息，他们认为在同一个 set 中的商品就应该是相关的，无论用户看到这个 set 的顺序或者时间是如何的。虽然这个假设在其他场景下不成立，不过可以认为在当前场景下是合理的。</p><p>因此，我们认为每对在同一个子集合中的商品是正例。这意味着集合的大小决定了窗口的大小。特别地，对于一个给定集合的商品，方程 $(1)$ 变为</p><p>$$<br>\frac{1}{K} \sum^K_{i = 1} \sum^K_{j \neq i} \log p(w_j | w_i)<br>$$</p><p>整个集合大小为 $K$，计算两两 pair 之间的 log 概率之和。</p><p>另一种方法，则保持方程 $(1)$ 不变，在执行期间 shuffle 每个集合内的商品。实验中发现两种方法最终的表现差不多。</p><p>后面的步骤与上一个 Section 保持一致，这就是 Item2Vec。工作中，我们使用 $u_i$ 作为第 $i$ 个商品的表达，而一对商品的相关性通过 cosine 相关性计算得到。另一种方法是使用 $v_i$，或者 $v_i + u_i$，或者它俩的 concatenation $[u^T_iv^T_i]^T$。最后两种方法优势有更好的效果。</p><h4 id="Item2Vec-效果">Item2Vec 效果</h4><p>将 Item2Vec 生成的 embedding 用作聚类，与基于 SVD 方法的用户 embedding 聚类结果进行比较，向量维度保持一致，即 $m = 40$。对比数据为音乐领域里 web 音乐人根据类别的聚类，同一个颜色的节点表示相同类型的音乐人。对比结果如下</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction-II/item2vec.jpg" alt="item2vec.jpg"></p><p>可以看出，两者差距不大，甚至 Item2Vec 的效果更好。</p><h4 id="Reference">Reference</h4><p><a href="https://arxiv.org/pdf/1603.04259v2.pdf">Item2Vec: Neural Item Embedding for Collaborative Filtering</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Item2Vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Embedding Introduction (I)</title>
      <link href="/2022/01/19/Embedding-Introduction/"/>
      <url>/2022/01/19/Embedding-Introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是-Embedding">什么是 Embedding ?</h4><p>广义得说， Embedding 就是一种用向量表达某个词汇的方式。其特点就是可以捕捉到文档中单词的上下文、语义与句法相似以及与其他单词的关系等。</p><p>考虑一下我们之前在做类别特征时常用的 one-hot 方法，假设整个上下文的单词量有 L，对任意一个单词，我们将其做 one-hot 转换成一个长度为 L 的向量，其中某个位置为 1，其余位置为 0。这样我们的确可以将单词映射到一个向量表达上。但当前还有一个问题：这样的表达可以表征两个单词的相关性么？</p><p>答案是不能，因为两个单词的计算 cosine 为 0。(在不同位置包含一个 1)</p><p>所以怎么才能体现相关性呢？可以考虑将这些 one-hot 矩阵映射到一个低位空间，使其向量值变稠密，同时保证“相似”词的 embedding 内积接近 1，不相似词的 embedding 内积接近 0，“相反”词的 embedding 内积接近 -1。这样的向量表达，就是我们常说的 embedding。</p><p>但是，这样的 embedding 需要如何生成呢？这篇文章就主要讲讲生成 embedding 的几种方法。</p><h4 id="生成-word-embeddings-的方式-一">生成 word embeddings 的方式 (一)</h4><h5 id="Word2Vec">Word2Vec</h5><p>word2vec 是一种使用浅神经网络训练 word embedding 的一种流行技巧。它主要通过两种包含神经网络的方式获得 embedding:   Skip Gram 和 CBOW (Common Bag Of Words)</p><p>而 embedding 从模型的什么部分获得呢？当模型训练完后，实际上我们得到了神经网络的权重，因为输入层是 one-hot 格式，到隐藏层时，相当于只有这个词对应的 embedding 被激活了，因而可以用这个 embedding 来表达该单词。</p><h6 id="CBOW-模型">CBOW 模型</h6><p>CBOW 模型：使用每个词的上下文作为输入，以预测准确这个词为训练目标，去训练整个神经网络模型。</p><p>只包含一个上下文单词 one-hot 作为输入的神经网络整体实际结构如下：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/CBOW_word2vec.png" alt="CBOW_word2vec.png"></p><p>这个输入，或者说这个上下文单词是一个大小为 V 的 one-hot 编码向量。隐藏层包含 N 个神经元，而输出则同样是一个 Size 为 V 的向量，其中的值通过了 Softmax 做归一化。目的是预测目标单词。</p><p>我们可以看到其中有两个权重矩阵 $W_{vn}$ 和 $W’_{nv}$ 。</p><p>这个神经网络中，唯一牵涉到非线性的地方就是输出层的 softmax，而没有用到其他激活函数，比如 sigmoid, tanh 或者 ReLU。</p><p>同样的，如果我们考虑的上下文单词不是一个，而是多个，则可以考虑如下结构：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/CBOW_word2vec_2.png" alt="CBOW_word2vec_2.png"></p><p>将 C 个上下文单词考虑入模型，均使用权重矩阵 $W_{vn}$ 计算隐藏层输入，再对所有 C 取平均值得到输出层的输入。这样，我们就可以使用上下文单词产生词表达。</p><h6 id="Skip-Gram-模型">Skip-Gram 模型</h6><p>整体结构如下，从某种意义上，这个结构就像 CBOW 结构翻转过来一样</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/skip_gram.png" alt="skip_gram.png"></p><p>对每个上下文位置，我们会得到 C 个 向量来预测词的可能性分布，每个向量对应一个单词。</p><p>两种模型都使用 backward propagation 负反馈的方式去迭代学习。</p><h6 id="优势场景">优势场景</h6><p>对于少量数据，skip gram 工作表现得更好，并且更能表达稀有词语。</p><p>CBOW 模型则对更频繁出现的词语表达更好，且更快。</p><h6 id="算法优化">算法优化</h6><p>文章中还提到了使用 Hierachical Softmax 和 Skip Gram 负采样的方式，使计算变得更有效率。详细文章可以参考<a href="https://arxiv.org/abs/1310.4546">原文</a> 或<a href="https://arxiv.org/pdf/1411.2738.pdf">Xin Rong 的论文</a></p><h5 id="总结-2">总结</h5><p>本文主要介绍了一下词表达的一种形式 embedding，并简单地讲述了 embedding 的两种基础训练方法：CBOW 和 skip-gram。</p><p>在学习过程中，发现一个有趣的地方。通过输入层与隐藏层间权重矩阵的某一列来表达某个单词，这个做法和 Factorization Machine 中某个特征的表达所用的矩阵有异曲同工之妙。同时，也希望自己能在一点点积累知识的同时能继续提升自己的写作能力。 并能手动复现这个基础的训练代码。``</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Word2Vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序代码实现</title>
      <link href="/2022/01/17/heap-sort/"/>
      <url>/2022/01/17/heap-sort/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是堆排序？">什么是堆排序？</h4><p>堆排序是一种基于比较的排序算法，需要借助于一种叫做二叉堆（Binary Heap）的数据结构。其操作和选择排序很相似，均可以认为是从某个数据结构中选出最小/最大的数出来。</p><h5 id="什么是二叉堆？">什么是二叉堆？</h5><p>在定义二叉堆之前，让我们先声明一个满二叉树（完全二叉树）的定义。一个满二叉树是一个除最后一层以外，其他层都被完全占满的二叉树。同时，满二叉树还要求树的节点尽可能地靠近左边。</p><p>而二叉堆，则是一个有特殊排序的满二叉树，他每个父节点的值，都比两个子节点的值大(或者小)。前者，被称为最大堆，后者，则是最小堆。这样的堆我们可以用二叉树或者数组来表达。</p><h5 id="怎么用数组的格式表达二叉堆？">怎么用数组的格式表达二叉堆？</h5><p>我们要充分利用好满二叉树每一层个数固定的性质。可以看到，如果一个父节点被存在了 <code>i</code> 位置，则其左子节点的位置为 <code>2 * i + 1</code>，而右子节点的位置为 <code>2 * i + 2</code>。这样的 array-base 的表达相比二叉树充分利用了空间。</p><h4 id="Heapify-过程">Heapify 过程</h4><p>将一个二叉树重构成一个堆数据结构的过程，被称作 heapify。</p><h5 id="增序的堆排序算法">增序的堆排序算法</h5><p>步骤：</p><ol><li><p>通过输入数据件一个最大堆。</p></li><li><p>最大的元素被放到了堆顶。用这个堆的最后一个值与堆顶交换，并使这个堆的 size 缩小一位。最终 heapify 树的根节点。</p></li><li><p>重复第 2 步，知道堆只剩一个元素。</p></li></ol><h5 id="代码实现">代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapify 一个根节点在 i 位置的子树，堆的大小为 n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序过程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0x01 建堆, 从第一个有子节点的节点开始 heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x02 一个一个从 heap 中取出最大元素，放到最后，直到堆只剩一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test case</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">17</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票问题系列--动态规划求解</title>
      <link href="/2022/01/16/stock-problem-dp/"/>
      <url>/2022/01/16/stock-problem-dp/</url>
      
        <content type="html"><![CDATA[<h4 id="前言-2">前言</h4><p>最近刷到多道 Best Time to Buy and Sell Stock 系列的问题，想要探究一下这类题目的通用动态规划解法。为此，特写了此文，找出这类问题的练习，供有面试需求的相关同学学习。</p><h5 id="相关题目">相关题目</h5><ol><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description">121. Best Time to Buy and Sell Stock</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description">122. Best Time to Buy and Sell Stock II</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description">123. Best Time to Buy and Sell Stock III</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description">188. Best Time to Buy and Sell Stock IV</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description">309. Best Time to Buy and Sell Stock with Cooldown</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. Best Time to Buy and Sell Stock with Transaction Fee</a></li></ol><h5 id="通用问题描述">通用问题描述</h5><p>给定一个数组 <code>vector&lt;int&gt;&amp; prices</code> ，这个数组代表了一个序列化的股票价格，在某些限制条件下，求能通过这些天的股票买卖获得的最大收益。</p><p>首先，我们来记录一下可能的限制条件：</p><ul><li><p>交易次数 <code>int k</code></p></li><li><p>交易冷却时间 <code>int time</code></p></li><li><p>交易费用 <code>int fee</code></p></li></ul><p>以及一些注明 (notation)：</p><ul><li>股票价格所处日期<code>int i</code>，第一天为 <code>0</code></li></ul><p>我们可以看到，上述的这类问题，其实都存在很明显的状态转移关系。</p><ul><li><p>当天有两个状态，持有股票与不持有股票</p></li><li><p>当天的状态，会与前面某天的状态有关。比如如果今天持有股票，则要么昨天也持有股票，要么需要再冷却期内不持有股票。</p></li></ul><h4 id="通用问题状态转移关系">通用问题状态转移关系</h4><p>我们定义一个三维矩阵<code>T</code>， 其中 <code>T[i][k][0]</code> 表示累计到第 <code>i</code> 天，进行了最多 <code>k</code> 次交易，并在第 <code>i</code> 天手上不持有股票下的最大收益；同样的，<code>T[i][k][0]</code> 表示累计到第 <code>i</code> 天，进行了最多 <code>k</code> 次交易，并在第 <code>i</code> 天手上持有股票的最大收益。目前我们可以依此写出base 条件与递归条件：</p><ol><li><p>base 情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始计算股票前一天的初始化，不持有股票认为是合法的，为 0，持有股票认为是不可能</span></span><br><span class="line">T[<span class="number">-1</span>][k][<span class="number">0</span>] = <span class="number">0</span>, T[<span class="number">-1</span>][k][<span class="number">1</span>] = INT_MIN</span><br><span class="line"><span class="comment">// 无可交易次数时的初始化，不持有股票认为是合法的，为 0，持有股票认为是不可能</span></span><br><span class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, T[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN</span><br></pre></td></tr></table></figure></li><li><p>递归关系：<br>2.1. 不持有股票的状态转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当天不持有股票的最大收益，认为是前一天不持有股票的最大收益，与前一天持有当卖出股票的最大收益之间的最大值。</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line"><span class="comment">// 如果考虑有交易费用，后一项的最大收益需要减去交易费用</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i] - fee);</span><br></pre></td></tr></table></figure><p>2.2. 持有股票的状态转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当天持有股票的最大收益，认为是前一天持有股票的最大收益，与前一天不持有而今天买入股票的最大收益</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"><span class="comment">// 如果考虑交易费用，除了上面 2.1 在卖出时支付交易费用外，还可以考虑是在买入时支付交易费用</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line"><span class="comment">// 如果考虑 cooldown 时间，那么我们能买入的条件也就不是前一天不持有股票，而是 cooldown 时间前不持有股票</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - time][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="特殊-cases-的求解">特殊 cases 的求解</h4><p>有了上述的通用状态转移关系，我们可以比较轻松得求解参数值固定的情况。</p><h5 id="case-I-k-1">case I : <code>k = 1</code></h5><p>当交易次数限制为 <code>k = 1</code> 时，每天 <code>i</code> 我们需要考虑两个状态下的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], T[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], - prices[i]);</span><br></pre></td></tr></table></figure><p>从而，这道题的解法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_10 = <span class="number">0</span>, T_11 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 每次迭代最多只会修改其中一个值</span></span><br><span class="line">            T_10 = <span class="built_in">max</span>(T_10, T_11 + price);</span><br><span class="line">            T_11 = <span class="built_in">max</span>(T_11, -price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-II-k-INT-MAX">Case II: <code>k = INT_MAX</code></h5><p>这个时候，其实 <code>T[i-1][k-1][0] = T[i-1][k][0]</code> 且 <code>T[i-1][k-1][1] = T[i-1][k][1]</code></p><p>每天 <code>i</code> ，我们仍然有两个变量未知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]) = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>从而，这道题的解法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-III-k-2">Case III : <code>k = 2</code></h5><p>和 case I 很相似，不过现在每天需要考察四个变量，其状态转移关系为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], - prices[i])</span><br></pre></td></tr></table></figure><p>同理，解法为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_10 = <span class="number">0</span>, T_11 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> T_20 = <span class="number">0</span>, T_21 = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            T_20 = <span class="built_in">max</span>(T_20, T_21 + price);</span><br><span class="line">            T_21 = <span class="built_in">max</span>(T_21, T_20 - price);</span><br><span class="line">            T_10 = <span class="built_in">max</span>(T_10, T_11 + price);</span><br><span class="line">            T_11 = <span class="built_in">max</span>(T_11, - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_20;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这样的方法，我们可以解任意 k 的结果。</p><h5 id="Case-IV-k-INT-MAX-但是有冷却">Case IV : <code>k = INT_MAX</code> 但是有冷却</h5><p>我们考虑 cool down 为 1 的情况，也就是如果我们想要在第 <code>i</code> 天买股票，那么我们只能在第 <code>i - 2</code> 前将股票卖出。状态转移方程变为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-2</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>解法修改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN, T_k0_pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_pre - price);</span><br><span class="line">            T_k0_pre = T_k0_old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-V-k-INT-MAX-有交易费用">Case V : <code>k = INT_MAX</code> 有交易费用</h5><p>在 case II 的基础上，考虑购买或卖出时收益多减去一个 fee 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i] - fee)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><h6 id="解法-I-买入时考虑费用">解法 I : 买入时考虑费用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price - fee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="解法-II-：卖出时考虑费用">解法 II ：卖出时考虑费用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price - fee);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="总结-3">总结</h5><p>对于这一类股票交易相关的问题，动态规划均可求解。</p><p>重点需要关注：</p><ul><li><p>交易日期 <code>i</code></p></li><li><p>最大允许交易次数 <code>k</code></p></li><li><p>每天能有的状态</p></li></ul><p>只要我们弄清楚每天这些状态之间的转移关系，就可以轻松 solve 这一系列问题。同时，弄清楚状态转移关系，还能对空间复杂度进行优化，不再需要使用一个数组去保留每天交易状态的最值。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Self Introduction</title>
      <link href="/2022/01/15/self-introduction/"/>
      <url>/2022/01/15/self-introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="Self-Introduction">Self Introduction</h4><p>My name is Jason Zeng, a junior machine learning engineer worked in Kuaishou Corporation last year. For the first half of the year, I was working as an intern in search scene of HashTag. My major target is to improve the ranking result by comparing query-photo relevance. While in the second half of the year, I became a full time employer in search scene of Electric Commerce. My major work is focus on the recall and coarse-grained ranking stage.</p><p>Prior to working, I gained my bachelor degree in University of Chinese Academy of Science in Beijing, and then I pursue my Ph.D. study in University of California, San Diego. In 2020, I quit my Ph.D. programme and went back to China with master degree.</p><p>That’s all for my introduction, thank you.</p>]]></content>
      
      
      <categories>
          
          <category> Resume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Resume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 Hexo 博客</title>
      <link href="/2022/01/14/%E6%90%AD%E5%BB%BAHexo-blog/"/>
      <url>/2022/01/14/%E6%90%AD%E5%BB%BAHexo-blog/</url>
      
        <content type="html"><![CDATA[<h4 id="Mac-安装-Node-js">Mac 安装 Node.js</h4><ul><li>最常用的方法是通过 Homebrew 进行 Node.js 和 npm 的安装。常用指令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新与安装 node</span></span><br><span class="line">brew update</span><br><span class="line">brew install node</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查安装版本</span></span><br><span class="line">brew list</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 node</span></span><br><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><h4 id="安装-Hexo">安装 Hexo</h4><ul><li>使用 npm 命令安装 Hexo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者安装 懒人包</span></span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h4 id="初始化-Hexo">初始化 Hexo</h4><ol><li><p>初始化一个 directory: <code>mkdir ~/hexo/dir &amp;&amp; cd ~/hexo/dir</code></p></li><li><p>初始化博客：<code>hexo init</code></p></li><li><p>静态编译博客 : <code>hexo g</code> \ <code>hexo generate</code></p></li><li><p>离线检查博客效果：<code>hexo s</code>\ <code>hexo server</code> 可以通过访问  <code>http://localhost:4000/</code> 本地检查效果</p></li><li><p>修改 config 文件，路径在 <code>~/hexo/dir/_config.yml</code>，需要修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type :</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>推到线上 <code>hexo d</code> \ <code>hexo deploy (-m message)</code></p></li></ol><h4 id="写博客并推到线上">写博客并推到线上</h4><ol><li><p>新建博客：<code>hexo n &quot;your title&quot;</code>\ <code>hexo new &quot;your title&quot;</code></p></li><li><p>进入相应路径修改 md 文件(写博客)： <code>cd ~/hexo/dir/source/_posts/your title.md</code></p></li><li><p>静态编译博客 : <code>hexo g</code> \ <code>hexo generate</code></p></li><li><p>离线检查博客效果：<code>hexo s</code>\ <code>hexo server</code> 可以通过访问 <code>http://localhost:4000/</code> 本地检查效果</p></li><li><p>推到线上 <code>hexo d</code> \ <code>hexo deploy (-m message)</code></p></li></ol><h4 id="个性化-Hexo-博客">个性化 Hexo 博客</h4><ul><li>参考：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔</a></li></ul><h5 id="如何对每一篇-post-做相应的修改？">如何对每一篇 post 做相应的修改？</h5><p>可参考 <a href="https://blog.csdn.net/qq_43857095/article/details/108306164"># Hexo butterfly 自定义文章封面 &amp;&amp; 主页顶部图片更改</a></p><p>比较重要的几个参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Hexo</span>, <span class="string">Nodejs</span>, <span class="string">git</span>] <span class="comment"># 或者用 - 隔行分隔</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">对这篇</span> <span class="string">blog</span> <span class="string">的描述</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/avocado.jpeg</span> <span class="comment"># 头部图片</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span> <span class="comment"># 是否现实评论</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/hashtag.jpeg</span> <span class="comment"># 封面图片</span></span><br></pre></td></tr></table></figure><p>如果没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h5 id="如何自动生成-categories-页或者-tags-页？">如何自动生成 categories 页或者 tags 页？</h5><ol><li><p>创建 categories page 或者 tags page，这时会在 source 文件夹下生成相应子文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>在相应的子文件夹中会生成 <code>index.md</code> 文件, 修改 <a href="http://index.md">index.md</a> 中的头文件配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-01-14 20:10:25</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/category.png</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/category.png</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>_config.butterfly.yml</code> 文件中的以下 command</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">My</span> <span class="string">Github</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/Jason24-Zeng/Jason24-Zeng.github.io/tree/main</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="literal">false</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下执行更新 blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

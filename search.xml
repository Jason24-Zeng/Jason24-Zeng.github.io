<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Embedding Introduction (I)</title>
      <link href="/2022/01/19/Embedding-Introduction/"/>
      <url>/2022/01/19/Embedding-Introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是-Embedding"><a href="#什么是-Embedding" class="headerlink" title="什么是 Embedding ?"></a>什么是 Embedding ?</h4><p>广义得说， Embedding 就是一种用向量表达某个词汇的方式。其特点就是可以捕捉到文档中单词的上下文、语义与句法相似以及与其他单词的关系等。</p><p>考虑一下我们之前在做类别特征时常用的 one-hot 方法，假设整个上下文的单词量有 L，对任意一个单词，我们将其做 one-hot 转换成一个长度为 L 的向量，其中某个位置为 1，其余位置为 0。这样我们的确可以将单词映射到一个向量表达上。但当前还有一个问题：这样的表达可以表征两个单词的相关性么？</p><p>答案是不能，因为两个单词的计算 cosine 为 0。(在不同位置包含一个 1)</p><p>所以怎么才能体现相关性呢？可以考虑将这些 one-hot 矩阵映射到一个低位空间，使其向量值变稠密，同时保证“相似”词的 embedding 内积接近 1，不相似词的 embedding 内积接近 0，“相反”词的 embedding 内积接近 -1。这样的向量表达，就是我们常说的 embedding。</p><p>但是，这样的 embedding 需要如何生成呢？这篇文章就主要讲讲生成 embedding 的几种方法。</p><h4 id="生成-word-embeddings-的方式-一"><a href="#生成-word-embeddings-的方式-一" class="headerlink" title="生成 word embeddings 的方式 (一)"></a>生成 word embeddings 的方式 (一)</h4><h5 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h5><p>word2vec 是一种使用浅神经网络训练 word embedding 的一种流行技巧。它主要通过两种包含神经网络的方式获得 embedding:   Skip Gram 和 CBOW (Common Bag Of Words)</p><p>而 embedding 从模型的什么部分获得呢？当模型训练完后，实际上我们得到了神经网络的权重，因为输入层是 one-hot 格式，到隐藏层时，相当于只有这个词对应的 embedding 被激活了，因而可以用这个 embedding 来表达该单词。</p><h6 id="CBOW-模型"><a href="#CBOW-模型" class="headerlink" title="CBOW 模型"></a>CBOW 模型</h6><p>CBOW 模型：使用每个词的上下文作为输入，以预测准确这个词为训练目标，去训练整个神经网络模型。</p><p>只包含一个上下文单词 one-hot 作为输入的神经网络整体实际结构如下：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/CBOW_word2vec.png" alt="CBOW_word2vec.png"></p><p>这个输入，或者说这个上下文单词是一个大小为 V 的 one-hot 编码向量。隐藏层包含 N 个神经元，而输出则同样是一个 Size 为 V 的向量，其中的值通过了 Softmax 做归一化。目的是预测目标单词。</p><p>我们可以看到其中有两个权重矩阵 $W_{vn}$ 和 $W’_{nv}$ 。</p><p>这个神经网络中，唯一牵涉到非线性的地方就是输出层的 softmax，而没有用到其他激活函数，比如 sigmoid, tanh 或者 ReLU。</p><p>同样的，如果我们考虑的上下文单词不是一个，而是多个，则可以考虑如下结构：</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/CBOW_word2vec_2.png" alt="CBOW_word2vec_2.png"></p><p>将 C 个上下文单词考虑入模型，均使用权重矩阵 $W_{vn}$ 计算隐藏层输入，再对所有 C 取平均值得到输出层的输入。这样，我们就可以使用上下文单词产生词表达。</p><h6 id="Skip-Gram-模型"><a href="#Skip-Gram-模型" class="headerlink" title="Skip-Gram 模型"></a>Skip-Gram 模型</h6><p>整体结构如下，从某种意义上，这个结构就像 CBOW 结构翻转过来一样</p><p><img src="https://jason24-zeng.github.io/img/Embedding-Introduction/skip_gram.png" alt="skip_gram.png"></p><p>对每个上下文位置，我们会得到 C 个 向量来预测词的可能性分布，每个向量对应一个单词。</p><p>两种模型都使用 backward propagation 负反馈的方式去迭代学习。</p><h6 id="优势场景"><a href="#优势场景" class="headerlink" title="优势场景"></a>优势场景</h6><p>对于少量数据，skip gram 工作得更好，并且更能表达稀有词语。</p><p>CBOW 模型则对更频繁出现的词语表达更高，且更快。</p><h6 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h6><p>文章中还提到了使用 Hierachical Softmax 和 Skip Gram 负采样的方式，使计算变得更有效率。详细文章可以参考<a href="https://arxiv.org/abs/1310.4546">原文</a> 或<a href="https://arxiv.org/pdf/1411.2738.pdf">Xin Rong 的论文</a></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>本文主要介绍了一下词表达的一种形式 embedding，并简单地讲述了 embedding 的两种基础训练方法：CBOW 和 skip-gram。</p><p>在学习过程中，发现一个有趣的地方。通过输入层与隐藏层间权重矩阵的某一列来表达某个单词，这个做法和 Factorization Machine 中某个特征的表达所用的矩阵有异曲同工之妙。同时，也希望自己能在一点点积累知识的同时能继续提升自己的写作能力。 并能手动复现这个基础的训练代码。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
          <category> Embedding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
            <tag> Word2Vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序代码实现</title>
      <link href="/2022/01/17/heap-sort/"/>
      <url>/2022/01/17/heap-sort/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是堆排序？"><a href="#什么是堆排序？" class="headerlink" title="什么是堆排序？"></a>什么是堆排序？</h4><p>堆排序是一种基于比较的排序算法，需要借助于一种叫做二叉堆（Binary Heap）的数据结构。其操作和选择排序很相似，均可以认为是从某个数据结构中选出最小/最大的数出来。</p><h5 id="什么是二叉堆？"><a href="#什么是二叉堆？" class="headerlink" title="什么是二叉堆？"></a>什么是二叉堆？</h5><p>在定义二叉堆之前，让我们先声明一个满二叉树（完全二叉树）的定义。一个满二叉树是一个除最后一层以外，其他层都被完全占满的二叉树。同时，满二叉树还要求树的节点尽可能地靠近左边。</p><p>而二叉堆，则是一个有特殊排序的满二叉树，他每个父节点的值，都比两个子节点的值大(或者小)。前者，被称为最大堆，后者，则是最小堆。这样的堆我们可以用二叉树或者数组来表达。</p><h5 id="怎么用数组的格式表达二叉堆？"><a href="#怎么用数组的格式表达二叉堆？" class="headerlink" title="怎么用数组的格式表达二叉堆？"></a>怎么用数组的格式表达二叉堆？</h5><p>我们要充分利用好满二叉树每一层个数固定的性质。可以看到，如果一个父节点被存在了 <code>i</code> 位置，则其左子节点的位置为 <code>2 * i + 1</code>，而右子节点的位置为 <code>2 * i + 2</code>。这样的 array-base 的表达相比二叉树充分利用了空间。</p><h4 id="Heapify-过程"><a href="#Heapify-过程" class="headerlink" title="Heapify 过程"></a>Heapify 过程</h4><p>将一个二叉树重构成一个堆数据结构的过程，被称作 heapify。</p><h5 id="增序的堆排序算法"><a href="#增序的堆排序算法" class="headerlink" title="增序的堆排序算法"></a>增序的堆排序算法</h5><p>步骤：</p><ol><li><p>通过输入数据件一个最大堆。</p></li><li><p>最大的元素被放到了堆顶。用这个堆的最后一个值与堆顶交换，并使这个堆的 size 缩小一位。最终 heapify 树的根节点。</p></li><li><p>重复第 2 步，知道堆只剩一个元素。</p></li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapify 一个根节点在 i 位置的子树，堆的大小为 n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序过程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 0x01 建堆, 从第一个有子节点的节点开始 heapify</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0x02 一个一个从 heap 中取出最大元素，放到最后，直到堆只剩一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test case</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">17</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">heapSort</span>(arr, n);</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票问题系列--动态规划求解</title>
      <link href="/2022/01/16/stock-problem-dp/"/>
      <url>/2022/01/16/stock-problem-dp/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近刷到多道 Best Time to Buy and Sell Stock 系列的问题，想要探究一下这类题目的通用动态规划解法。为此，特写了此文，找出这类问题的练习，供有面试需求的相关同学学习。</p><h5 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h5><ol><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description">121. Best Time to Buy and Sell Stock</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/#/description">122. Best Time to Buy and Sell Stock II</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/#/description">123. Best Time to Buy and Sell Stock III</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/#/description">188. Best Time to Buy and Sell Stock IV</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description">309. Best Time to Buy and Sell Stock with Cooldown</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. Best Time to Buy and Sell Stock with Transaction Fee</a></li></ol><h5 id="通用问题描述"><a href="#通用问题描述" class="headerlink" title="通用问题描述"></a>通用问题描述</h5><p>给定一个数组 <code>vector&lt;int&gt;&amp; prices</code> ，这个数组代表了一个序列化的股票价格，在某些限制条件下，求能通过这些天的股票买卖获得的最大收益。</p><p>首先，我们来记录一下可能的限制条件：</p><ul><li><p>交易次数 <code>int k</code></p></li><li><p>交易冷却时间 <code>int time</code></p></li><li><p>交易费用 <code>int fee</code></p></li></ul><p>以及一些注明 (notation)：</p><ul><li>股票价格所处日期<code>int i</code>，第一天为 <code>0</code></li></ul><p>我们可以看到，上述的这类问题，其实都存在很明显的状态转移关系。</p><ul><li><p>当天有两个状态，持有股票与不持有股票</p></li><li><p>当天的状态，会与前面某天的状态有关。比如如果今天持有股票，则要么昨天也持有股票，要么需要再冷却期内不持有股票。</p></li></ul><h4 id="通用问题状态转移关系"><a href="#通用问题状态转移关系" class="headerlink" title="通用问题状态转移关系"></a>通用问题状态转移关系</h4><p>我们定义一个三维矩阵<code>T</code>， 其中 <code>T[i][k][0]</code> 表示累计到第 <code>i</code> 天，进行了最多 <code>k</code> 次交易，并在第 <code>i</code> 天手上不持有股票下的最大收益；同样的，<code>T[i][k][0]</code> 表示累计到第 <code>i</code> 天，进行了最多 <code>k</code> 次交易，并在第 <code>i</code> 天手上持有股票的最大收益。目前我们可以依此写出base 条件与递归条件：</p><ol><li><p>base 情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始计算股票前一天的初始化，不持有股票认为是合法的，为 0，持有股票认为是不可能</span></span><br><span class="line">T[<span class="number">-1</span>][k][<span class="number">0</span>] = <span class="number">0</span>, T[<span class="number">-1</span>][k][<span class="number">1</span>] = INT_MIN</span><br><span class="line"><span class="comment">// 无可交易次数时的初始化，不持有股票认为是合法的，为 0，持有股票认为是不可能</span></span><br><span class="line">T[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, T[i][<span class="number">0</span>][<span class="number">1</span>] = INT_MIN</span><br></pre></td></tr></table></figure></li><li><p>递归关系：<br>2.1. 不持有股票的状态转移:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当天不持有股票的最大收益，认为是前一天不持有股票的最大收益，与前一天持有当卖出股票的最大收益之间的最大值。</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line"><span class="comment">// 如果考虑有交易费用，后一项的最大收益需要减去交易费用</span></span><br><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">0</span>], T[i - <span class="number">1</span>][k][<span class="number">1</span>] + prices[i] - fee);</span><br></pre></td></tr></table></figure><p>2.2. 持有股票的状态转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当天持有股票的最大收益，认为是前一天持有股票的最大收益，与前一天不持有而今天买入股票的最大收益</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"><span class="comment">// 如果考虑交易费用，除了上面 2.1 在卖出时支付交易费用外，还可以考虑是在买入时支付交易费用</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - <span class="number">1</span>][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);</span><br><span class="line"><span class="comment">// 如果考虑 cooldown 时间，那么我们能买入的条件也就不是前一天不持有股票，而是 cooldown 时间前不持有股票</span></span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][k][<span class="number">1</span>], T[i - time][k - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="特殊-cases-的求解"><a href="#特殊-cases-的求解" class="headerlink" title="特殊 cases 的求解"></a>特殊 cases 的求解</h4><p>有了上述的通用状态转移关系，我们可以比较轻松得求解参数值固定的情况。</p><h5 id="case-I-k-1"><a href="#case-I-k-1" class="headerlink" title="case I : k = 1"></a>case I : <code>k = 1</code></h5><p>当交易次数限制为 <code>k = 1</code> 时，每天 <code>i</code> 我们需要考虑两个状态下的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], T[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) = <span class="built_in">max</span>(T[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], - prices[i]);</span><br></pre></td></tr></table></figure><p>从而，这道题的解法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_10 = <span class="number">0</span>, T_11 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 每次迭代最多只会修改其中一个值</span></span><br><span class="line">            T_10 = <span class="built_in">max</span>(T_10, T_11 + price);</span><br><span class="line">            T_11 = <span class="built_in">max</span>(T_11, -price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-II-k-INT-MAX"><a href="#Case-II-k-INT-MAX" class="headerlink" title="Case II: k = INT_MAX"></a>Case II: <code>k = INT_MAX</code></h5><p>这个时候，其实 <code>T[i-1][k-1][0] = T[i-1][k][0]</code> 且 <code>T[i-1][k-1][1] = T[i-1][k][1]</code></p><p>每天 <code>i</code> ，我们仍然有两个变量未知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]) = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>从而，这道题的解法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-III-k-2"><a href="#Case-III-k-2" class="headerlink" title="Case III : k = 2"></a>Case III : <code>k = 2</code></h5><p>和 case I 很相似，不过现在每天需要考察四个变量，其状态转移关系为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T[i][<span class="number">2</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], - prices[i])</span><br></pre></td></tr></table></figure><p>同理，解法为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_10 = <span class="number">0</span>, T_11 = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> T_20 = <span class="number">0</span>, T_21 = INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            T_20 = <span class="built_in">max</span>(T_20, T_21 + price);</span><br><span class="line">            T_21 = <span class="built_in">max</span>(T_21, T_20 - price);</span><br><span class="line">            T_10 = <span class="built_in">max</span>(T_10, T_11 + price);</span><br><span class="line">            T_11 = <span class="built_in">max</span>(T_11, - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_20;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这样的方法，我们可以解任意 k 的结果。</p><h5 id="Case-IV-k-INT-MAX-但是有冷却"><a href="#Case-IV-k-INT-MAX-但是有冷却" class="headerlink" title="Case IV : k = INT_MAX 但是有冷却"></a>Case IV : <code>k = INT_MAX</code> 但是有冷却</h5><p>我们考虑 cool down 为 1 的情况，也就是如果我们想要在第 <code>i</code> 天买股票，那么我们只能在第 <code>i - 2</code> 前将股票卖出。状态转移方程变为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-2</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>解法修改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN, T_k0_pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_pre - price);</span><br><span class="line">            T_k0_pre = T_k0_old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Case-V-k-INT-MAX-有交易费用"><a href="#Case-V-k-INT-MAX-有交易费用" class="headerlink" title="Case V : k = INT_MAX 有交易费用"></a>Case V : <code>k = INT_MAX</code> 有交易费用</h5><p>在 case II 的基础上，考虑购买或卖出时收益多减去一个 fee 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i] - fee)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[i][k][<span class="number">0</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">0</span>], T[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">T[i][k][<span class="number">1</span>] = <span class="built_in">max</span>(T[i<span class="number">-1</span>][k][<span class="number">1</span>], T[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><h6 id="解法-I-买入时考虑费用"><a href="#解法-I-买入时考虑费用" class="headerlink" title="解法 I : 买入时考虑费用"></a>解法 I : 买入时考虑费用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price - fee);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="解法-II-：卖出时考虑费用"><a href="#解法-II-：卖出时考虑费用" class="headerlink" title="解法 II ：卖出时考虑费用"></a>解法 II ：卖出时考虑费用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> T_k0 = <span class="number">0</span>, T_k1 = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> T_k0_old = T_k0;</span><br><span class="line">            T_k0 = <span class="built_in">max</span>(T_k0, T_k1 + price - fee);</span><br><span class="line">            T_k1 = <span class="built_in">max</span>(T_k1, T_k0_old - price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_k0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对于这一类股票交易相关的问题，动态规划均可求解。</p><p>重点需要关注：</p><ul><li><p>交易日期 <code>i</code></p></li><li><p>最大允许交易次数 <code>k</code></p></li><li><p>每天能有的状态</p></li></ul><p>只要我们弄清楚每天这些状态之间的转移关系，就可以轻松 solve 这一系列问题。同时，弄清楚状态转移关系，还能对空间复杂度进行优化，不再需要使用一个数组去保留每天交易状态的最值。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Dynamic Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Self Introduction</title>
      <link href="/2022/01/15/self-introduction/"/>
      <url>/2022/01/15/self-introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="Self-Introduction"><a href="#Self-Introduction" class="headerlink" title="Self Introduction"></a>Self Introduction</h4><p>My name is Jason Zeng, a junior machine learning engineer worked in Kuaishou Corporation last year. For the first half of the year, I was working as an intern in search scene of HashTag. My major target is to improve the ranking result by comparing query-photo relevance. While in the second half of the year, I became a full time employer in search scene of Electric Commerce. My major work is focus on the recall and coarse-grained ranking stage.</p><p>Prior to working, I gained my bachelor degree in University of Chinese Academy of Science in Beijing, and then I pursue my Ph.D. study in University of California, San Diego. In 2020, I quit my Ph.D. programme and went back to China with master degree.</p><p>That’s all for my introduction, thank you.</p>]]></content>
      
      
      <categories>
          
          <category> Resume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Resume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 Hexo 博客</title>
      <link href="/2022/01/14/%E6%90%AD%E5%BB%BAHexo-blog/"/>
      <url>/2022/01/14/%E6%90%AD%E5%BB%BAHexo-blog/</url>
      
        <content type="html"><![CDATA[<h4 id="Mac-安装-Node-js"><a href="#Mac-安装-Node-js" class="headerlink" title="Mac 安装 Node.js"></a>Mac 安装 Node.js</h4><ul><li>最常用的方法是通过 Homebrew 进行 Node.js 和 npm 的安装。常用指令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新与安装 node</span></span><br><span class="line">brew update</span><br><span class="line">brew install node</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查安装版本</span></span><br><span class="line">brew list</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 node</span></span><br><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><ul><li>使用 npm 命令安装 Hexo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者安装 懒人包</span></span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h4 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h4><ol><li><p>初始化一个 directory: <code>mkdir ~/hexo/dir &amp;&amp; cd ~/hexo/dir</code></p></li><li><p>初始化博客：<code>hexo init</code></p></li><li><p>静态编译博客 : <code>hexo g</code> \ <code>hexo generate</code></p></li><li><p>离线检查博客效果：<code>hexo s</code>\ <code>hexo server</code> 可以通过访问  <code>http://localhost:4000/</code> 本地检查效果</p></li><li><p>修改 config 文件，路径在 <code>~/hexo/dir/_config.yml</code>，需要修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type :</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">git@github.com:username/username.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li><p>推到线上 <code>hexo d</code> \ <code>hexo deploy (-m message)</code></p></li></ol><h4 id="写博客并推到线上"><a href="#写博客并推到线上" class="headerlink" title="写博客并推到线上"></a>写博客并推到线上</h4><ol><li><p>新建博客：<code>hexo n &quot;your title&quot;</code>\ <code>hexo new &quot;your title&quot;</code></p></li><li><p>进入相应路径修改 md 文件(写博客)： <code>cd ~/hexo/dir/source/_posts/your title.md</code></p></li><li><p>静态编译博客 : <code>hexo g</code> \ <code>hexo generate</code></p></li><li><p>离线检查博客效果：<code>hexo s</code>\ <code>hexo server</code> 可以通过访问 <code>http://localhost:4000/</code> 本地检查效果</p></li><li><p>推到线上 <code>hexo d</code> \ <code>hexo deploy (-m message)</code></p></li></ol><h4 id="个性化-Hexo-博客"><a href="#个性化-Hexo-博客" class="headerlink" title="个性化 Hexo 博客"></a>个性化 Hexo 博客</h4><ul><li>参考：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔</a></li></ul><h5 id="如何对每一篇-post-做相应的修改？"><a href="#如何对每一篇-post-做相应的修改？" class="headerlink" title="如何对每一篇 post 做相应的修改？"></a>如何对每一篇 post 做相应的修改？</h5><p>可参考 <a href="https://blog.csdn.net/qq_43857095/article/details/108306164"># Hexo butterfly 自定义文章封面 &amp;&amp; 主页顶部图片更改</a></p><p>比较重要的几个参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Hexo</span>, <span class="string">Nodejs</span>, <span class="string">git</span>] <span class="comment"># 或者用 - 隔行分隔</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">对这篇</span> <span class="string">blog</span> <span class="string">的描述</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/avocado.jpeg</span> <span class="comment"># 头部图片</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span> <span class="comment"># 是否现实评论</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/hashtag.jpeg</span> <span class="comment"># 封面图片</span></span><br></pre></td></tr></table></figure><p>如果没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h5 id="如何自动生成-categories-页或者-tags-页？"><a href="#如何自动生成-categories-页或者-tags-页？" class="headerlink" title="如何自动生成 categories 页或者 tags 页？"></a>如何自动生成 categories 页或者 tags 页？</h5><ol><li><p>创建 categories page 或者 tags page，这时会在 source 文件夹下生成相应子文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>在相应的子文件夹中会生成 <code>index.md</code> 文件, 修改 index.md 中的头文件配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-01-14 20:10:25</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/img/category.png</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="string">/img/category.png</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>_config.butterfly.yml</code> 文件中的以下 command</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">My</span> <span class="string">Github</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/Jason24-Zeng/Jason24-Zeng.github.io/tree/main</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="literal">false</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下执行更新 blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
